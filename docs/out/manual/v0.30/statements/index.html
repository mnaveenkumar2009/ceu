<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Statements - Céu v0.30 - Reference Manual</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  <link href="../extra.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Statements";
    var mkdocs_page_input_path = "statements/index.md";
    var mkdocs_page_url = "/statements/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Céu v0.30 - Reference Manual</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Overview</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lexical_rules/">Lexical Rules</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../types/">Types</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../storage_entities/">Storage Entities</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Statements</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#statements">Statements</a></li>
                
                    <li><a class="toctree-l4" href="#nothing">Nothing</a></li>
                
                    <li><a class="toctree-l4" href="#blocks">Blocks</a></li>
                
                    <li><a class="toctree-l4" href="#declarations">Declarations</a></li>
                
                    <li><a class="toctree-l4" href="#assignments">Assignments</a></li>
                
                    <li><a class="toctree-l4" href="#event-handling">Event Handling</a></li>
                
                    <li><a class="toctree-l4" href="#conditional">Conditional</a></li>
                
                    <li><a class="toctree-l4" href="#loops">Loops</a></li>
                
                    <li><a class="toctree-l4" href="#parallel-compositions">Parallel Compositions</a></li>
                
                    <li><a class="toctree-l4" href="#pausing_1">Pausing</a></li>
                
                    <li><a class="toctree-l4" href="#exceptions">Exceptions</a></li>
                
                    <li><a class="toctree-l4" href="#asynchronous-execution">Asynchronous Execution</a></li>
                
                    <li><a class="toctree-l4" href="#c-integration">C Integration</a></li>
                
                    <li><a class="toctree-l4" href="#lua-integration">Lua Integration</a></li>
                
                    <li><a class="toctree-l4" href="#abstractions">Abstractions</a></li>
                
                    <li><a class="toctree-l4" href="#synchronous-control-statements">Synchronous Control Statements</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../expressions/">Locations & Expressions</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../compilation/">Compilation</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../syntax/">Syntax</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../license/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Céu v0.30 - Reference Manual</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Statements</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="statements">Statements<a class="headerlink" href="#statements" title="Permanent link">&para;</a></h1>
<p>A program in Céu is a sequence of statements delimited by an implicit enclosing
block:</p>
<pre><code class="ceu">Program ::= Block
Block   ::= {Stmt `;´}
</code></pre>

<p><em>Note: statements terminated with the <code>end</code> keyword do not require a
terminating semicolon.</em></p>
<h2 id="nothing">Nothing<a class="headerlink" href="#nothing" title="Permanent link">&para;</a></h2>
<p><code>nothing</code> is an innocuous statement:</p>
<pre><code class="ceu">Nothing ::= nothing
</code></pre>

<h2 id="blocks">Blocks<a class="headerlink" href="#blocks" title="Permanent link">&para;</a></h2>
<p>A <code>Block</code> delimits a lexical scope for
<a href="./../storage_entities/#entity-classes">storage entities</a>
and
<a href="#abstractions">abstractions</a>,
which are only visible to statements inside the block.</p>
<p>Compound statements (e.g. <em>do-end</em>, <em>if-then-else</em>, <em>loops</em>, etc.) create new
blocks and can be nested to an arbitrary level.</p>
<h3 id="do-end-and-escape"><code>do-end</code> and <code>escape</code><a class="headerlink" href="#do-end-and-escape" title="Permanent link">&para;</a></h3>
<p>The <code>do-end</code> statement creates an explicit block.
The <code>escape</code> statement terminates the deepest matching enclosing <code>do-end</code>:</p>
<pre><code class="ceu">Do ::= do [`/´(ID_int|`_´)] [`(´ [LIST(ID_int)] `)´]
           Block
       end

Escape ::= escape [`/´ID_int] [Exp]
</code></pre>

<p>A <code>do-end</code> and <code>escape</code> accept an optional identifier following the symbol <code>/</code>.
An <code>escape</code> only matches a <code>do-end</code> with the same identifier.
The neutral identifier <code>_</code> in a <code>do-end</code> is guaranteed not to match any
<code>escape</code> statement.</p>
<p>A <code>do-end</code> also supports an optional list of identifiers in parenthesis which
restricts the visible storage entities inside the block to those matching the
list.
An empty list hides all storage entities from the enclosing scope.</p>
<p>A <code>do-end</code> can be <a href="#assignments">assigned</a> to a variable whose type must be
matched by nested <code>escape</code> statements.
The whole block evaluates to the value of a reached <code>escape</code>.
If the variable is of <a href="./../types/#option">option type</a>, the <code>do-end</code> is allowed
to terminate without an <code>escape</code>, otherwise it raises a runtime error.</p>
<p>Programs have an implicit enclosing <code>do-end</code> that assigns to a
<em>program status variable</em> of type <code>int</code> whose meaning is platform dependent.</p>
<p>Examples:</p>
<pre><code class="ceu">do
    do/a
        do/_
            escape;     // matches line 1
        end
        escape/a;       // matches line 2
    end
end
</code></pre>

<pre><code class="ceu">var int a;
var int b;
do (a)
    a = 1;
    b = 2;  // &quot;b&quot; is not visible
end
</code></pre>

<pre><code class="ceu">var int? v =
    do
        if &lt;cnd&gt; then
            escape 10;  // assigns 10 to &quot;v&quot;
        else
            nothing;    // &quot;v&quot; remains unassigned
        end
    end;
</code></pre>

<pre><code class="ceu">escape 0;               // program terminates with a status value of 0
</code></pre>

<h3 id="pre-do-end"><code>pre-do-end</code><a class="headerlink" href="#pre-do-end" title="Permanent link">&para;</a></h3>
<p>The <code>pre-do-end</code> statement prepends its statements in the beginning of the
program:</p>
<pre><code class="ceu">Pre_Do ::= pre do
               Block
           end
</code></pre>

<p>All <code>pre-do-end</code> statements are concatenated together in the order they appear
and are moved to the beginning of the top-level block, before all other
statements.</p>
<h2 id="declarations">Declarations<a class="headerlink" href="#declarations" title="Permanent link">&para;</a></h2>
<p>A declaration introduces a <a href="./../storage_entities/#storage-entities">storage entity</a>
to the enclosing block.
All declarations are subject to <a href="./../storage_entities/#lexical-scope">lexical scope</a>.</p>
<p>Céu supports variables, vectors, pools, internal events, and external events:</p>
<pre><code class="ceu">
Var  ::= var [`&amp;´|`&amp;?´] [ `[´ [Exp [`*`]] `]´ ] [`/dynamic´|`/nohold´] Type ID_int [`=´ Sources]
Pool ::= pool [`&amp;´] `[´ [Exp] `]´ Type ID_int [`=´ Sources]
Int  ::= event [`&amp;´] (Type | `(´ LIST(Type) `)´) ID_int [`=´ Sources]

Ext  ::= input  (Type | `(´ LIST(Type) `)´) ID_ext
      |  output (Type | `(´ LIST([`&amp;´] Type [ID_int]) `)´) ID_ext
            [ do Block end ]

Sources ::= /* (see &quot;Assignments&quot;) */
</code></pre>

<p>Most declarations support an initialization <a href="#assignments">assignment</a>.</p>
<!--
See also [Storage Classes](#TODO) for an overview of storage entities.
-->

<h3 id="variables">Variables<a class="headerlink" href="#variables" title="Permanent link">&para;</a></h3>
<p>A <a href="./../storage_entities/#variables">variable</a> declaration has an associated
<a href="./../types/#types">type</a> and can be optionally <a href="#assignments">initialized</a>.
Declarations can also be
<a href="./../storage_entities/#aliases">aliases or option aliases</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">var  int v = 10;    // &quot;v&quot; is an integer variable initialized to 10
var  int a=0, b=3;  // &quot;a&quot; and &quot;b&quot; are integer variables initialized to 0 and 3
var&amp; int z = &amp;v;    // &quot;z&quot; is an alias to &quot;v&quot;
</code></pre>

<h3 id="vectors">Vectors<a class="headerlink" href="#vectors" title="Permanent link">&para;</a></h3>
<p>A <a href="./../storage_entities/#vectors">vector</a> declaration specifies a
<a href="#dimension">dimension</a> between brackets,
an associated <a href="./../types/#types">type</a> and can be optionally
<a href="#assignments">initialized</a>.
Declarations can also be <a href="./../storage_entities/#aliases">aliases</a>.
<code>TODO: ring buffers</code></p>
<!--
`TODO: unmacthing [] in binding`
-->

<p>Examples:</p>
<pre><code class="ceu">var int n = 10;
var[10] int vs1 = [];    // &quot;vs1&quot; is a static vector of 10 elements max
var[n]  int vs2 = [];    // &quot;vs2&quot; is a dynamic vector of 10 elements max
var[]   int vs3 = [];    // &quot;vs3&quot; is an unbounded vector
var&amp;[]  int vs4 = &amp;vs1;  // &quot;vs4&quot; is an alias to &quot;vs1&quot;
</code></pre>

<h3 id="pools">Pools<a class="headerlink" href="#pools" title="Permanent link">&para;</a></h3>
<p>A <a href="./../storage_entities/#pools">pool</a> declaration specifies a dimension and an
associated <a href="./../types/#types">type</a>.
Declarations for pools can also be <a href="./../storage_entities/#aliases">aliases</a>.
Only in this case they can be <a href="#assignments">initialized</a>.</p>
<p>The expression between the brackets specifies the <a href="#dimension">dimension</a> of
the pool.</p>
<p>Examples:</p>
<pre><code class="ceu">code/await Play (...) do ... end
pool[10] Play plays;        // &quot;plays&quot; is a static pool of 10 elements max
pool&amp;[]  Play a = &amp;plays;   // &quot;a&quot; is an alias to &quot;plays&quot;
</code></pre>

<!--
See also [Code Invocation](#TODO).
-->

<p><code>TODO: data pools</code></p>
<h3 id="dimension">Dimension<a class="headerlink" href="#dimension" title="Permanent link">&para;</a></h3>
<p>Declarations for <a href="#vectors">vectors</a> or <a href="#pools">pools</a> require an expression
between brackets to specify a dimension as follows:</p>
<ul>
<li><em>constant expression</em>: Maximum number of elements is fixed and space is
                         statically pre-allocated.</li>
<li><em>variable expression</em>: Maximum number of elements is fixed but space is
                         dynamically allocated.
                         The expression is evaulated once at declaration time.</li>
<li><em>omitted</em>: Maximum number of elements is unbounded and space is dynamically
             allocated.
             The space for dynamic dimensions grow and shrink automatically.</li>
<li><code>TODO: ring buffers</code></li>
</ul>
<h3 id="events">Events<a class="headerlink" href="#events" title="Permanent link">&para;</a></h3>
<p>An <a href="./../storage_entities/#events">event</a> declaration specifies a
<a href="./../types/#types">type</a> for the values it carries when occurring.
It can be also a list of types if the event communicates multiple values.</p>
<!--
See also [Introduction](#TODO) for a general overview of events.
-->

<h4 id="external-events">External Events<a class="headerlink" href="#external-events" title="Permanent link">&para;</a></h4>
<p>Examples:</p>
<pre><code class="ceu">input  none A;          // &quot;A&quot; is an input event carrying no values
output int  MY_EVT;     // &quot;MY_EVT&quot; is an output event carrying integer values
input (int,byte&amp;&amp;) BUF; // &quot;BUF&quot; is an input event carrying an &quot;(int,byte&amp;&amp;)&quot; pair
</code></pre>

<p><code>TODO: output &amp;/impl</code></p>
<h4 id="internal-events">Internal Events<a class="headerlink" href="#internal-events" title="Permanent link">&para;</a></h4>
<p>Declarations for internal events can also be
<a href="./../storage_entities/#aliases">aliases</a>.
Only in this case they can be <a href="#assignments">initialized</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">event  none a;          // &quot;a&quot; is an internal events carrying no values
event&amp; none z = &amp;a;     // &quot;z&quot; is an alias to event &quot;a&quot;
event (int,int) c;      // &quot;c&quot; is a internal event carrying an &quot;(int,int)&quot; pair
</code></pre>

<h2 id="assignments">Assignments<a class="headerlink" href="#assignments" title="Permanent link">&para;</a></h2>
<p>An assignment associates the statement or expression at the right side of the
symbol <code>=</code> with the <a href="./../storage_entities/#locations">location(s)</a> at the left side:</p>
<pre><code class="ceu">Assignment ::= (Loc | `(´ LIST(Loc|`_´) `)´) `=´ Sources

Sources ::= ( Do
            | Emit_Ext
            | Await
            | Watching
            | Thread
            | Lua_Stmts
            | Code_Await
            | Code_Spawn
            | Vec_Cons
            | Data_Cons
            | Exp
            | `_´ )
</code></pre>

<p>Céu supports the following constructs as assignment sources:</p>
<ul>
<li><a href="#do-end-and-escape"><code>do-end</code> block</a></li>
<li><a href="#events_1">external emit</a></li>
<li><a href="#await">await</a></li>
<li><a href="#watching">watching statement</a></li>
<li><a href="#thread">thread</a></li>
<li><a href="#lua-statement">lua statement</a></li>
<li><a href="#code-invocation">code await</a></li>
<li><a href="#code-invocation">code spawn</a></li>
<li>vector <a href="./../expressions/#length">length</a> &amp; <a href="./../expressions/#constructor">constructor</a></li>
<li><a href="#data-constructor">data constructor</a></li>
<li><a href="./../expressions/#locations-expressions">expression</a></li>
<li>the special identifier <code>_</code></li>
</ul>
<p>The special identifier <code>_</code> makes the assignment innocuous.
In the case of assigning to an <a href="./../types/#option">option type</a>, the <code>_</code> unsets
it.</p>
<p><code>TODO: required for uninitialized variables</code></p>
<h3 id="copy-assignment">Copy Assignment<a class="headerlink" href="#copy-assignment" title="Permanent link">&para;</a></h3>
<p>A <em>copy assignment</em> evaluates the statement or expression at the right side and
copies the result(s) to the location(s) at the left side.</p>
<h3 id="alias-assignment">Alias Assignment<a class="headerlink" href="#alias-assignment" title="Permanent link">&para;</a></h3>
<p>An <em>alias assignment</em>, aka <em>binding</em>, makes the location at the left side to be
an <a href="./../storage_entities/#aliases">alias</a> to the expression at the right side.</p>
<p>The right side of a binding must always be prefixed with the operator <code>&amp;</code>.</p>
<h2 id="event-handling">Event Handling<a class="headerlink" href="#event-handling" title="Permanent link">&para;</a></h2>
<h3 id="await">Await<a class="headerlink" href="#await" title="Permanent link">&para;</a></h3>
<p>The <code>await</code> statement halts the running trail until the specified event occurs.
The event can be an <a href="./../storage_entities/#external-events">input event</a>, an
<a href="./../storage_entities/#internal-events">internal event</a>, a terminating
<a href="#code">code abstraction</a>, a timer, a
<a href="#pausing_1">pausing event</a>, or forever (i.e., never awakes):</p>
<pre><code class="ceu">Await ::= await (ID_ext | Loc) [until Exp]      /* events and option aliases */
       |  await (WCLOCKK|WCLOCKE)               /* timers */
       |  await (pause|resume)                  /* pausing events */
       |  await FOREVER                         /* forever */
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">await A;                  // awaits the input event &quot;A&quot;
await a until v==10;      // awaits the internal event &quot;a&quot; until the condition is satisfied

var&amp;? My_Code my = &lt;...&gt;; // acquires a reference to a code abstraction instance
await my;                 // awaits it terminate

await 1min10s30ms100us;   // awaits the specified time
await (t)ms;              // awaits the current value of the variable &quot;t&quot; in milliseconds

await FOREVER;            // awaits forever
</code></pre>

<p>An <code>await</code> evaluates to zero or more values which can be captured with an
optional <a href="#assignments">assignment</a>.</p>
<h4 id="event">Event<a class="headerlink" href="#event" title="Permanent link">&para;</a></h4>
<p>The <code>await</code> statement for events halts the running trail until the specified
<a href="./../storage_entities/#external-events">input event</a> or
<a href="./../storage_entities/#internal-events">internal event</a> occurs.
The <code>await</code> evaluates to a value of the type of the event.</p>
<p>The optional clause <code>until</code> tests an awaking condition.
The condition can use the returned value from the <code>await</code>.
It expands to a <a href="#simple-loop"><code>loop</code></a> as follows:</p>
<pre><code class="ceu">loop do
    &lt;ret&gt; = await &lt;evt&gt;;
    if &lt;Exp&gt; then   // &lt;Exp&gt; can use &lt;ret&gt;
        break;
    end
end
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">input int E;                    // &quot;E&quot; is an input event carrying &quot;int&quot; values
var int v = await E until v&gt;10; // assigns occurring &quot;E&quot; to &quot;v&quot;, awaking only when &quot;v&gt;10&quot;

event (bool,int) e;             // &quot;e&quot; is an internal event carrying &quot;(bool,int)&quot; pairs
var bool v1;
var int  v2;
(v1,v2) = await e;              // awakes on &quot;e&quot; and assigns its values to &quot;v1&quot; and &quot;v2&quot;
</code></pre>

<h4 id="code-abstraction">Code Abstraction<a class="headerlink" href="#code-abstraction" title="Permanent link">&para;</a></h4>
<p>The <code>await</code> statement for a <a href="#code">code abstraction</a> halts the running trail
until the specified instance terminates.</p>
<p>The <code>await</code> evaluates to the return value of the abstraction.</p>
<p><code>TODO: option return on kill</code></p>
<p>Example:</p>
<pre><code class="ceu">var&amp;? My_Code my = spawn My_Code();
var? int ret = await my;
</code></pre>

<h4 id="timer">Timer<a class="headerlink" href="#timer" title="Permanent link">&para;</a></h4>
<p>The <code>await</code> statement for timers halts the running trail until the specified
timer expires:</p>
<ul>
<li><code>WCLOCKK</code> specifies a constant timer expressed as a sequence of value/unit
  pairs.</li>
<li><code>WCLOCKE</code> specifies an <a href="./../types/#primitives">integer</a> expression in
  parenthesis followed by a single unit of time.</li>
</ul>
<p>The <code>await</code> evaluates to a value of type <code>s32</code> and is the
<em>residual delta time (<code>dt</code>)</em> measured in microseconds:
    the difference between the actual elapsed time and the requested time.
The residual <code>dt</code> is always greater than or equal to 0.</p>
<p>If a program awaits timers in sequence (or in a <code>loop</code>), the residual <code>dt</code> from
the preceding timer is reduced from the timer in sequence.</p>
<p>Examples:</p>
<pre><code class="ceu">var int t = &lt;...&gt;;
await (t)ms;                // awakes after &quot;t&quot; milliseconds
</code></pre>

<pre><code class="ceu">var int dt = await 100us;   // if 1000us elapses, then dt=900us (1000-100)
await 100us;                // since dt=900, this timer is also expired, now dt=800us (900-100)
await 1ms;                  // this timer only awaits 200us (1000-800)
</code></pre>

<!--
Refer to [[#Environment]] for information about storage types for *wall-clock*
time.
-->

<h4 id="pausing">Pausing<a class="headerlink" href="#pausing" title="Permanent link">&para;</a></h4>
<p>Pausing events are dicussed in <a href="#pausing_1">Pausing</a>.</p>
<h4 id="forever"><code>FOREVER</code><a class="headerlink" href="#forever" title="Permanent link">&para;</a></h4>
<p>The <code>await</code> statement for <code>FOREVER</code> halts the running trail forever.
It cannot be used in assignments because it never evaluates to anything.</p>
<p>Example:</p>
<pre><code class="ceu">if v==10 then
    await FOREVER;  // this trail never awakes if condition is true
end
</code></pre>

<h3 id="emit">Emit<a class="headerlink" href="#emit" title="Permanent link">&para;</a></h3>
<p>The <code>emit</code> statement broadcasts an event to the whole program.
The event can be an <a href="./../storage_entities/#external-events">external event</a>, an
<a href="./../storage_entities/#internal-events">internal event</a>, or a timer:</p>
<pre><code class="ceu">Emit_Int ::= emit Loc [`(´ [LIST(Exp)] `)´]
Emit_Ext ::= emit ID_ext [`(´ [LIST(Exp)] `)´]
          |  emit (WCLOCKK|WCLOCKE)
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">emit A;         // emits the output event `A` of type &quot;none&quot;
emit a(1);      // emits the internal event `a` of type &quot;int&quot;

emit 1s;        // emits the specified time
emit (t)ms;     // emits the current value of the variable `t` in milliseconds
</code></pre>

<h4 id="events_1">Events<a class="headerlink" href="#events_1" title="Permanent link">&para;</a></h4>
<p>The <code>emit</code> statement for events expects the arguments to match the event type.</p>
<p>An <code>emit</code> to an input or timer event can only occur inside
<a href="#asynchronous-block">asynchronous blocks</a>.</p>
<p>An <code>emit</code> to an output event is also an expression that evaluates to a value of
type <code>s32</code> and can be captured with an optional <a href="#assignments">assignment</a> (its
meaning is platform dependent).</p>
<p>An <code>emit</code> to an internal event starts a new
<a href="./../#internal-reactions">internal reaction</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">input int I;
async do
    emit I(10);         // broadcasts &quot;I&quot; to the application itself, passing &quot;10&quot;
end

output none O;
var int ret = emit O(); // outputs &quot;O&quot; to the environment and captures the result

event (int,int) e;
emit e(1,2);            // broadcasts &quot;e&quot; passing a pair of &quot;int&quot; values
</code></pre>

<h4 id="timer_1">Timer<a class="headerlink" href="#timer_1" title="Permanent link">&para;</a></h4>
<p>The <code>emit</code> statement for timers expects a <a href="#timer">timer expression</a>.</p>
<p>Like input events, time can only be emitted inside <a href="#asynchronous-blocks">asynchronous 
blocks</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">async do
    emit 1s;    // broadcasts &quot;1s&quot; to the application itself
end
</code></pre>

<h3 id="lock">Lock<a class="headerlink" href="#lock" title="Permanent link">&para;</a></h3>
<p><code>TODO</code></p>
<h2 id="conditional">Conditional<a class="headerlink" href="#conditional" title="Permanent link">&para;</a></h2>
<p>The <code>if-then-else</code> statement provides conditional execution in Céu:</p>
<pre><code class="ceu">If ::= if Exp then
           Block
       { else/if Exp then
           Block }
       [ else
           Block ]
       end
</code></pre>

<p>Each condition <code>Exp</code> is tested in sequence, first for the <code>if</code> clause and then
for each of the optional <code>else/if</code> clauses.
On the first condition that evaluates to <code>true</code>, the <code>Block</code> following it
executes.
If all conditions fail, the optional <code>else</code> clause executes.</p>
<p>All conditions must evaluate to a value of type <a href="./../types/#primitives"><code>bool</code></a>.
<!--, which is checked at compile time.--></p>
<h2 id="loops">Loops<a class="headerlink" href="#loops" title="Permanent link">&para;</a></h2>
<p>Céu supports simple loops, numeric iterators, event iterators, and pool
iterators:</p>
<pre><code class="ceu">Loop ::=
      /* simple loop */
        loop [`/´Exp] do
            Block
        end

      /* numeric iterator */
      | loop [`/´Exp] NumericRange do
            Block
        end

      /* event iterator */
      | every [(Loc | `(´ LIST(Loc|`_´) `)´) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do
            Block
        end

      /* pool iterator */
      | loop [`/´Exp] (ID_int|`_´) in Loc do
            Block
        end

Break    ::= break [`/´ID_int]
Continue ::= continue [`/´ID_int]

NumericRange ::= /* (see &quot;Numeric Iterator&quot;) */
</code></pre>

<p>The body of a loop <code>Block</code> executes an arbitrary number of times, depending on
the conditions imposed by each kind of loop.</p>
<p>Except for the <code>every</code> iterator, all loops support an optional constant
expression <code>&grave;/&acute;Exp</code> that limits the maximum number of
iterations to avoid <a href="#bounded-execution">infinite execution</a>.
If the number of iterations reaches the limit, a runtime error occurs.</p>
<!--
The expression must be a constant evaluated at compile time.
-->

<h3 id="break-and-continue"><code>break</code> and <code>continue</code><a class="headerlink" href="#break-and-continue" title="Permanent link">&para;</a></h3>
<p>The <code>break</code> statement aborts the deepest enclosing loop.</p>
<p>The <code>continue</code> statement aborts the body of the deepest enclosing loop and
restarts it in the next iteration.</p>
<p>The optional modifier <code>&grave;/&acute;ID_int</code> in both statements
only applies to <a href="#numeric-iterator">numeric iterators</a>.</p>
<h3 id="simple-loop">Simple Loop<a class="headerlink" href="#simple-loop" title="Permanent link">&para;</a></h3>
<p>The simple <code>loop-do-end</code> statement executes its body forever:</p>
<pre><code class="ceu">SimpleLoop ::= loop [`/´Exp] do
                   Block
               end
</code></pre>

<p>The only way to terminate a simple loop is with the <code>break</code> statement.</p>
<p>Examples:</p>
<pre><code class="ceu">// blinks a LED with a frequency of 1s forever
loop do
    emit LED(1);
    await 1s;
    emit LED(0);
    await 1s;
end
</code></pre>

<pre><code class="ceu">loop do
    loop do
        if &lt;cnd-1&gt; then
            break;      // aborts the loop at line 2 if &lt;cnd-1&gt; is satisfied
        end
    end
    if &lt;cnd-2&gt; then
        continue;       // restarts the loop at line 1 if &lt;cnd-2&gt; is satisfied
    end
end
</code></pre>

<h3 id="numeric-iterator">Numeric Iterator<a class="headerlink" href="#numeric-iterator" title="Permanent link">&para;</a></h3>
<p>The numeric loop executes its body a fixed number of times based on a numeric
range for a control variable:</p>
<pre><code class="ceu">NumericIterator ::= loop [`/´Exp] NumericRange do
                        Block
                    end

NumericRange ::= (`_´|ID_int) in [ (`[´ | `]´)
                                       ( (     Exp `-&gt;´ (`_´|Exp))
                                       | (`_´|Exp) `&lt;-´ Exp      ) )
                                   (`[´ | `]´) [`,´ Exp] ]
</code></pre>

<p>The control variable assumes the values specified in the interval, one by one,
for each iteration of the loop body:</p>
<ul>
<li><strong>control variable:</strong>
    <code>ID_int</code> is a read-only variable of a <a href="./../types/#primitives">numeric type</a>.
    Alternatively, the special anonymous identifier <code>_</code> can be used if the body
    of the loop does not access the variable.</li>
<li>
<p><strong>interval:</strong>
    Specifies a direction, endpoints with open or closed modifiers, and a step.</p>
<ul>
<li><strong>direction</strong>:<ul>
<li><code>-&gt;</code>: Starts from the endpoint <code>Exp</code> on the left increasing towards <code>Exp</code> on the right.</li>
<li><code>&lt;-</code>: Starts from the endpoint <code>Exp</code> on the right decreasing towards <code>Exp</code> on the left.
Typically, the value on the left is smaller or equal to the value on
the right.</li>
</ul>
</li>
<li><strong>endpoints</strong>:
    <code>[Exp</code> and <code>Exp]</code> are closed intervals which include <code>Exp</code> as the
    endpoints;
    <code>]Exp</code> and <code>Exp[</code> are open intervals which exclude <code>Exp</code> as the
    endpoints.
    Alternatively, the finishing endpoint may be <code>_</code> which means that the
    interval goes towards infinite.</li>
<li><strong>step</strong>:
    An optional positive number added or subtracted towards the limit.
    If the step is omitted, it assumes the value <code>1</code>.
    If the direction is <code>-&gt;</code>, the step is added, otherwise it is subtracted.</li>
</ul>
<p>If the interval is not specified, it assumes the default <code>[0 -&gt; _[</code>.</p>
</li>
</ul>
<p>A numeric iterator executes as follows:</p>
<ul>
<li>
<p><strong>initialization:</strong>
    The starting endpoint is assigned to the control variable.
    If the starting enpoint is open, the control variable accumulates a step
    immediately.</p>
</li>
<li>
<p><strong>iteration:</strong></p>
<ol>
<li><strong>limit check:</strong>
    If the control variable crossed the finishing endpoint, the loop
    terminates.</li>
<li><strong>body execution:</strong>
    The loop body executes.</li>
<li><strong>step</strong>
    Applies a step to the control variable. Goto step <code>1</code>.</li>
</ol>
</li>
</ul>
<p>The <code>break</code> and <code>continue</code> statements inside numeric iterators accept an
optional modifier <code>&grave;/&acute;ID_int</code> to affect the enclosing
loop matching the control variable.</p>
<p>Examples:</p>
<pre><code class="ceu">// prints &quot;i=0&quot;, &quot;i=1&quot;, ...
var int i;
loop i do
    _printf(&quot;i=%d\n&quot;, i);
end
</code></pre>

<pre><code class="ceu">// awaits 1s and prints &quot;Hello World!&quot; 10 times
loop _ in [0 -&gt; 10[ do
    await 1s;
    _printf(&quot;Hello World!\n&quot;);
end
</code></pre>

<pre><code class="ceu">var int i;
loop i do
    var int j;
    loop j do
        if &lt;cnd-1&gt; then
            continue/i;         // continues the loop at line 1
        else/if &lt;cnd-2&gt; then
            break/j;            // breaks the loop at line 4
        end
    end
end
</code></pre>

<p><em>Note : the runtime asserts that the step is a positive number and that the
        control variable does not overflow.</em></p>
<h3 id="event-iterator">Event Iterator<a class="headerlink" href="#event-iterator" title="Permanent link">&para;</a></h3>
<p>The <code>every</code> statement iterates over an event continuously, executing its
body whenever the event occurs:</p>
<pre><code class="ceu">EventIterator ::= every [(Loc | `(´ LIST(Loc|`_´) `)´) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do
                      Block
                  end
</code></pre>

<p>The event can be an <a href="#event">external or internal event</a> or a <a href="#timer">timer</a>.</p>
<p>The optional assignment to a variable (or list of variables) stores the
carrying value(s) of the event.</p>
<p>An <code>every</code> expands to a <code>loop</code> as illustrated below:</p>
<pre><code class="ceu">every &lt;vars&gt; in &lt;event&gt; do
    &lt;body&gt;
end
</code></pre>

<p>is equivalent to</p>
<pre><code class="ceu">loop do
    &lt;vars&gt; = await &lt;event&gt;;
    &lt;body&gt;
end
</code></pre>

<p>However, the body of an <code>every</code> cannot contain
<a href="#synchronous-control-statements">synchronous control statements</a>, ensuring
that no occurrences of the specified event are ever missed.</p>
<p><code>TODO: reject break inside every</code></p>
<p>Examples:</p>
<pre><code class="ceu">every 1s do
    _printf(&quot;Hello World!\n&quot;);      // prints the &quot;Hello World!&quot; message on every second
end
</code></pre>

<pre><code class="ceu">event (bool,int) e;
var bool cnd;
var int  v;
every (cnd,v) in e do
    if not cnd then
        break;                      // terminates when the received &quot;cnd&quot; is false
    else
        _printf(&quot;v = %d\n&quot;, v);     // prints the received &quot;v&quot; otherwise
    end
end
</code></pre>

<h3 id="pool-iterator">Pool Iterator<a class="headerlink" href="#pool-iterator" title="Permanent link">&para;</a></h3>
<p>The <a href="./../storage_entities/#pools">pool</a> iterator visits all alive
<a href="#code">abstraction</a> instances residing in a given pool:</p>
<pre><code class="ceu">PoolIterator ::= loop [`/´Exp] (ID_int|`_´) in Loc do
                     Block
                 end
</code></pre>

<p>On each iteration, the optional control variable becomes a
<a href="#code-references">reference</a> to an instance, starting from the oldest created
to the newest.</p>
<p>The control variable must be an alias to the same type of the pool with the
same rules that apply to <a href="#code-invocation"><code>spawn</code></a>.</p>
<p>Examples:</p>
<pre><code>pool[] My_Code my_codes;

&lt;...&gt;

var&amp;? My_Code my_code;
loop my_code in mycodes do
    &lt;...&gt;
end
</code></pre>

<h2 id="parallel-compositions">Parallel Compositions<a class="headerlink" href="#parallel-compositions" title="Permanent link">&para;</a></h2>
<pre><code class="ceu">Pars ::= (par | par/and | par/or) do
             Block
         with
             Block
         { with
             Block }
         end

Spawn ::= spawn [`(´ [LIST(ID_int)] `)´] do
              Block
          end

Watching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Abs_Cons) do
                 Block
             end
</code></pre>

<p>The parallel statements <code>par/and</code>, <code>par/or</code>, and <code>par</code> fork the running trail 
in multiple others.
They differ only on how trails rejoin and terminate the composition.</p>
<p>The <code>spawn</code> statement starts to execute a block in parallel with the enclosing
block.</p>
<p>The <code>watching</code> statement executes a block and terminates when one of its
specified events occur.</p>
<p>See also <a href="./../#parallel-compositions-and-abortion">Parallel Compositions and Abortion</a>.</p>
<h3 id="par">par<a class="headerlink" href="#par" title="Permanent link">&para;</a></h3>
<p>The <code>par</code> statement never rejoins.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts continuously to &quot;1s&quot; and &quot;KEY_PRESSED&quot; and never terminates
input none KEY_PRESSED;
par do
    every 1s do
        &lt;...&gt;           // does something every &quot;1s&quot;
    end
with
    every KEY_PRESSED do
        &lt;...&gt;           // does something every &quot;KEY_PRESSED&quot;
    end
end
</code></pre>

<h3 id="parand">par/and<a class="headerlink" href="#parand" title="Permanent link">&para;</a></h3>
<p>The <code>par/and</code> statement stands for <em>parallel-and</em> and rejoins when all nested
trails terminate.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts once to &quot;1s&quot; and &quot;KEY_PRESSED&quot; and terminates
input none KEY_PRESSED;
par/and do
    await 1s;
    &lt;...&gt;               // does something after &quot;1s&quot;
with
    await KEY_PRESSED;
    &lt;...&gt;               // does something after &quot;KEY_PRESSED&quot;
end
</code></pre>

<h3 id="paror">par/or<a class="headerlink" href="#paror" title="Permanent link">&para;</a></h3>
<p>The <code>par/or</code> statement stands for <em>parallel-or</em> and rejoins when any of the 
trails terminate, aborting all other trails.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts once to `1s` or `KEY_PRESSED` and terminates
input none KEY_PRESSED;
par/or do
    await 1s;
    &lt;...&gt;               // does something after &quot;1s&quot;
with
    await KEY_PRESSED;
    &lt;...&gt;               // does something after &quot;KEY_PRESSED&quot;
end
</code></pre>

<h3 id="spawn">spawn<a class="headerlink" href="#spawn" title="Permanent link">&para;</a></h3>
<p>The <code>spawn</code> statement starts to execute a block in parallel with the enclosing
block.
When the enclosing block terminates, the spawned block is aborted.</p>
<p>Like a <a href="#do-end-and-escape"><code>do-end</code> block</a>, a <code>spawn</code> also supports an
optional list of identifiers in parenthesis which restricts the visible
variables inside the block to those matching the list.</p>
<p>Examples:</p>
<pre><code class="ceu">spawn do
    every 1s do
        &lt;...&gt;       // does something every &quot;1s&quot;...
    end
end

&lt;...&gt;               // ...in parallel with whatever comes next
</code></pre>

<h3 id="watching">watching<a class="headerlink" href="#watching" title="Permanent link">&para;</a></h3>
<p>A <code>watching</code> expands to a <code>par/or</code> with <em>n+1</em> trails:
one to await each of the listed events,
and one to execute its body, i.e.:</p>
<pre><code class="ceu">watching &lt;e1&gt;,&lt;e2&gt;,... do
    &lt;body&gt;
end
</code></pre>

<p>expands to</p>
<pre><code class="ceu">par/or do
    await &lt;e1&gt;;
with
    await &lt;e2&gt;;
with
    ...
with
    &lt;body&gt;
end
</code></pre>

<p>The <code>watching</code> statement accepts a list of events and terminates when any of
them occur.
The events are the same supported by the <a href="#await"><code>await</code></a> statement.
It evaluates to what the occurring event value(s), which can be captured with
an optional <a href="#assignments">assignment</a>.</p>
<p>If the event is a <a href="#code">code abstraction</a>, the nested blocked does not
require the unwrap operator <a href="./../expressions/#option"><code>!</code></a>.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts continuously to &quot;KEY_PRESSED&quot; during &quot;1s&quot;
input none KEY_PRESSED;
watching 1s do
    every KEY_PRESSED do
        &lt;...&gt;           // does something every &quot;KEY_PRESSED&quot;
    end
end
</code></pre>

<h2 id="pausing_1">Pausing<a class="headerlink" href="#pausing_1" title="Permanent link">&para;</a></h2>
<p>The <code>pause/if</code> statement controls if its body should temporarily stop to react
to events:</p>
<pre><code class="ceu">Pause_If ::= pause/if (Loc|ID_ext) do
                 Block
             end

Pause_Await ::= await (pause|resume)
</code></pre>

<p>A <code>pause/if</code> specifies a pausing event of type <code>bool</code> which, when emitted,
toggles between pausing (<code>true</code>) and resuming (<code>false</code>) reactions for its body.</p>
<p>When its body terminates, the whole <code>pause/if</code> terminates and proceeds to the
statement in sequence.</p>
<p>In transition instants, the body can react to the special <code>pause</code> and <code>resume</code>
events before the corresponding state applies.</p>
<p><code>TODO: finalize/pause/resume</code></p>
<p>Examples:</p>
<pre><code class="ceu">event bool e;
pause/if e do       // pauses/resumes the nested body on each &quot;e&quot;
    every 1s do
        &lt;...&gt;       // does something every &quot;1s&quot;
    end
end
</code></pre>

<pre><code class="ceu">event bool e;
pause/if e do               // pauses/resumes the nested body on each &quot;e&quot;
    &lt;...&gt;
        loop do
            await pause;
            &lt;...&gt;           // does something before pausing
            await resume;
            &lt;...&gt;           // does something before resuming
        end
    &lt;...&gt;
end
</code></pre>

<!--
*Note: The timeouts for timers remain frozen while paused.*
-->

<h2 id="exceptions">Exceptions<a class="headerlink" href="#exceptions" title="Permanent link">&para;</a></h2>
<p><code>TODO</code></p>
<pre><code class="ceu">Throw ::= throw Exp
Catch ::= catch LIST(Loc) do
              Block
          end
</code></pre>

<h2 id="asynchronous-execution">Asynchronous Execution<a class="headerlink" href="#asynchronous-execution" title="Permanent link">&para;</a></h2>
<p>Asynchronous execution allow programs to departure from the rigorous
synchronous model and preform computations under separate scheduling rules.</p>
<p>Céu supports <em>asynchronous blocks</em>, <em>threads</em>, and
<em>interrupt service routines</em>:</p>
<pre><code class="ceu">Async  ::= await async [ `(´LIST(Var)`)´ ] do
               Block
           end

Thread ::= await async/thread [ `(´LIST(Var)`)´ ] do
               Block
           end

Isr ::= spawn async/isr `[´ LIST(Exp) `]´ [ `(´ LIST(Var) `)´ ] do
            Block
        end

Atomic ::= atomic do
               Block
           end
</code></pre>

<p>Asynchronous execution supports <a href="./../#bounded-execution">tight loops</a> while
keeping the rest of the application, aka the <em>synchronous side</em>, reactive to
incoming events.  However, it does not support any
<a href="#synchronous-control-statements">synchronous control statement</a> (e.g.,
parallel compositions, event handling, pausing, etc.).</p>
<p>By default, asynchronous bodies do not share variables with their enclosing
scope, but the optional list of variables makes them visible to the block.</p>
<p>Even though asynchronous blocks execute in separate, they are still managed by
the program hierarchy and are also subject to lexical scope and abortion.</p>
<!--
 execute time consuming computations 
without interfering with the responsiveness of the  *synchronous side* of
applications (i.e., all core language statements):

The program awaits the termination of the asynchronous `Block` body to proceed to the
statement in sequence.
-->

<h3 id="asynchronous-block">Asynchronous Block<a class="headerlink" href="#asynchronous-block" title="Permanent link">&para;</a></h3>
<p>Asynchronous blocks, aka <em>asyncs</em>, intercalate execution with the synchronous
side as follows:</p>
<ol>
<li>Start/Resume whenever the synchronous side is idle.
   When multiple <em>asyncs</em> are active, they execute in lexical order.</li>
<li>Suspend after each <code>loop</code> iteration.</li>
<li>Suspend on every input <code>emit</code> (see <a href="#simulation">Simulation</a>).</li>
<li>Execute atomically and to completion unless rules <code>2</code> and <code>3</code> apply.</li>
</ol>
<p>This rules imply that <em>asyncs</em> never execute with real parallelism with the
synchronous side, preserving determinism in the program.</p>
<p>Examples:</p>
<pre><code class="ceu">// calculates the factorial of some &quot;v&quot; if it doesn't take too long
var u64  v   = &lt;...&gt;;
var u64  fat = 1;
var bool ok  = false;
watching 1s do
    await async (v,fat) do      // keeps &quot;v&quot; and &quot;fat&quot; visible
        loop i in [1 -&gt; v] do   // reads from &quot;v&quot;
            fat = fat * i;      // writes to &quot;fat&quot;
        end
    end
    ok = true;                  // completed within &quot;1s&quot;
end
</code></pre>

<h4 id="simulation">Simulation<a class="headerlink" href="#simulation" title="Permanent link">&para;</a></h4>
<p>An <code>async</code> block can emit <a href="#events_1">input and timer events</a> towards the
synchronous side, providing a way to test programs in the language itself.
Every time an <code>async</code> emits an event, it suspends until the synchronous side
reacts to the event (see <a href="#asynchronous-block"><code>rule 1</code></a> above).</p>
<p>Examples:</p>
<pre><code class="ceu">input int A;

// tests a program with input simulation in parallel
par do

    // original program
    var int v = await A;
    loop i in [0 -&gt; _[ do
        await 10ms;
        _printf(&quot;v = %d\n&quot;, v+i);
    end

with

    // input simulation
    async do
        emit A(0);      // initial value for &quot;v&quot;
        emit 1s35ms;    // the loop in the original program executes 103 times
    end
    escape 0;

end

// The example prints the message `v = &lt;v+i&gt;` exactly 103 times.
</code></pre>

<h3 id="thread">Thread<a class="headerlink" href="#thread" title="Permanent link">&para;</a></h3>
<p>Threads provide real parallelism for applications in Céu.
Once started, a thread executes completely detached from the synchronous side.
For this reason, thread execution is non deterministic and require explicit
<a href="#atomic-block">atomic blocks</a> on accesses to variables to avoid race
conditions.</p>
<p>A thread evaluates to a boolean value which indicates whether it started
successfully or not.
The value can be captured with an optional <a href="#assignment">assignment</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">// calculates the factorial of some &quot;v&quot; if it doesn't take too long
var u64  v   = &lt;...&gt;;
var u64  fat = 1;
var bool ok  = false;
watching 1s do
    await async/thread (v,fat) do   // keeps &quot;v&quot; and &quot;fat&quot; visible
        loop i in [1 -&gt; v] do       // reads from &quot;v&quot;
            fat = fat * i;          // writes to &quot;fat&quot;
        end
    end
    ok = true;                      // completed within &quot;1s&quot;
end
</code></pre>

<h3 id="asynchronous-interrupt-service-routine">Asynchronous Interrupt Service Routine<a class="headerlink" href="#asynchronous-interrupt-service-routine" title="Permanent link">&para;</a></h3>
<p><code>TODO</code></p>
<h3 id="atomic-block">Atomic Block<a class="headerlink" href="#atomic-block" title="Permanent link">&para;</a></h3>
<p>Atomic blocks provide mutual exclusion among threads, interrupts, and the
synchronous side of application.
Once an atomic block starts to execute, no other atomic block in the program
starts.</p>
<p>Examples:</p>
<pre><code class="ceu">// A &quot;race&quot; between two threads: one incrementing, the other decrementing &quot;count&quot;.

var s64 count = 0;                              // &quot;count&quot; is a shared variable
par do
    every 1s do
        atomic do
            _printf(&quot;count = %d\n&quot;, count);     // prints current value of &quot;count&quot; every &quot;1s&quot;
        end
    end
with
    await async/thread (count) do
        loop do
            atomic do
                count = count - 1;              // decrements &quot;count&quot; as fast as possible
            end
        end
    end
with
    await async/thread (count) do
        loop do
            atomic do
                count = count + 1;              // increments &quot;count&quot; as fast as possible
            end
        end
    end
end
</code></pre>

<h2 id="c-integration">C Integration<a class="headerlink" href="#c-integration" title="Permanent link">&para;</a></h2>
<!--
Céu integrates safely with C, and programs can define and make native calls
seamlessly while avoiding memory leaks and dangling pointers when dealing with
external resources.
-->

<p>Céu provides <a href="#native-declaration">native declarations</a> to import C symbols,
<a href="#native-block">native blocks</a> to define new code in C,
<a href="#native-statement">native statements</a> to inline C statements,
<a href="#native-call">native calls</a> to call C functions,
and <a href="#resources-finalization">finalization</a> to deal with C pointers safely:</p>
<pre><code class="ceu">Nat_Symbol ::= native [`/´(pure|const|nohold|plain)] `(´ LIST(ID_nat) `)´
Nat_Block  ::= native `/´(pre|pos) do
                   &lt;code definitions in C&gt;
               end
Nat_End    ::= native `/´ end

Nat_Stmts  ::= `{´ {&lt;code in C&gt; | `@´ (`(´Exp`)´|Exp)} `}´     /* `@@´ escapes to `@´ */

Nat_Call   ::= [call] (Loc | `(´ Exp `)´)  `(´ [ LIST(Exp)] `)´

Finalization ::= do [Stmt] Finalize
              |  var [`&amp;´|`&amp;?´] Type ID_int `=´ `&amp;´ (Call_Nat | Call_Code) Finalize
Finalize ::= finalize [ `(´ LIST(Loc) `)´ ] with
                 Block
             [ pause  with Block ]
             [ resume with Block ]
             end
</code></pre>

<p>Native calls and statements transfer execution to C, losing the guarantees of
the <a href="./../#synchronous-execution-model">synchronous model</a>.
For this reason, programs should only resort to C for asynchronous
functionality (e.g., non-blocking I/O) or simple <code>struct</code> accessors, but
never for control purposes.</p>
<p><code>TODO: Nat_End</code></p>
<h3 id="native-declaration">Native Declaration<a class="headerlink" href="#native-declaration" title="Permanent link">&para;</a></h3>
<p>In Céu, any <a href="./../lexical_rules/#identifiers">identifier</a> prefixed with an
underscore is a native symbol defined externally in C.
However, all external symbols must be declared before their first use in a
program.</p>
<p>Native declarations support four modifiers as follows:</p>
<ul>
<li><code>const</code>: declares the listed symbols as constants.
    Constants can be used as bounded limits in <a href="#vectors">vectors</a>,
    <a href="#pools">pools</a>, and <a href="./../statements/#numeric-iterator">numeric loops</a>.
    Also, constants cannot be <a href="#assignments">assigned</a>.</li>
<li><code>plain</code>: declares the listed symbols as <em>plain</em> types, i.e., types (or
    composite types) that do not contain pointers.
    A value of a plain type passed as argument to a function does not require
    <a href="./../statements/#resources-finalization">finalization</a>.</li>
<li><code>nohold</code>: declares the listed symbols as <em>non-holding</em> functions, i.e.,
    functions that do not retain received pointers after returning.
    Pointers passed to non-holding functions do not require
    <a href="./../statements/#resources-finalization">finalization</a>.</li>
<li><code>pure</code>: declares the listed symbols as pure functions.
    In addition to the <code>nohold</code> properties, pure functions never allocate
    resources that require <a href="./../statements/#resources-finalization">finalization</a>
    and have no side effects to take into account for the <a href="#TODO">safety checks</a>.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">// values
native/const  _LOW, _HIGH;      // Arduino &quot;LOW&quot; and &quot;HIGH&quot; are constants
native        _errno;           // POSIX &quot;errno&quot; is a global variable

// types
native/plain  _char;            // &quot;char&quot; is a &quot;plain&quot; type
native        _SDL_PixelFormat; // SDL &quot;SDL_PixelFormat&quot; is a type holding a pointer

// functions
native        _uv_read_start;   // Libuv &quot;uv_read_start&quot; retains the received pointer
native/nohold _free;            // POSIX &quot;free&quot; receives a pointer but does not retain it
native/pure   _strlen;          // POSIX &quot;strlen&quot; is a &quot;pure&quot; function
</code></pre>

<h3 id="native-block">Native Block<a class="headerlink" href="#native-block" title="Permanent link">&para;</a></h3>
<p>A native block allows programs to define new external symbols in C.</p>
<p>The contents of native blocks is copied unchanged to the output in C depending
on the modifier specified:</p>
<ul>
<li><code>pre</code>: code is placed before the declarations for the Céu program.
    Symbols defined in <code>pre</code> blocks are visible to Céu.</li>
<li><code>pos</code>: code is placed after the declarations for the Céu program.
    Symbols implicitly defined by the compiler of Céu are visible to <code>pos</code>
    blocks.</li>
</ul>
<p>Native blocks are copied in the order they appear in the source code.</p>
<p>Since Céu uses the <a href="./../compilation/#compilation">C preprocessor</a>, hash
directives <code>#</code> inside native blocks must be quoted as <code>##</code> to be considered
only in the C compilation phase.</p>
<p>If the code in C contains the terminating <code>end</code> keyword of Céu, the <code>native</code>
block should be delimited with matching comments to avoid confusing the parser:</p>
<p>Symbols defined in native blocks still need to be
<a href="#native-declaration">declared</a> for use in the program.</p>
<p>Examples:</p>
<pre><code class="ceu">native/plain _t;
native/pre do
    typedef int t;              // definition for &quot;t&quot; is placed before Céu declarations
end
var _t x = 10;                  // requires &quot;t&quot; to be already defined
</code></pre>

<pre><code class="ceu">input none A;                   // declaration for &quot;A&quot; is placed before &quot;pos&quot; blocks
native _get_A_id;
native/pos do
    int get_A_id (void) {
        return CEU_INPUT_A;     // requires &quot;A&quot; to be already declared
    }
end
</code></pre>

<pre><code class="ceu">native/nohold _printf;
native/pre do
    ##include &lt;stdio.h&gt;         // include the relevant header for &quot;printf&quot;
end
</code></pre>

<pre><code class="ceu">native/pos do
    /******/
    char str = &quot;This `end` confuses the parser&quot;;
    /******/
end
</code></pre>

<h3 id="native-statement">Native Statement<a class="headerlink" href="#native-statement" title="Permanent link">&para;</a></h3>
<p>The contents of native statements in between <code>{</code> and <code>}</code> are inlined in the
program.</p>
<p>Native statements support interpolation of expressions in Céu which are
expanded when preceded by the symbol <code>@</code>.</p>
<p>Examples:</p>
<pre><code class="ceu">var int v_ceu = 10;
{
    int v_c = @v_ceu * 2;       // yields 20
}
v_ceu = { v_c + @v_ceu };       // yields 30
{
    printf(&quot;%d\n&quot;, @v_ceu);     // prints 30
}
</code></pre>

<h3 id="native-call">Native Call<a class="headerlink" href="#native-call" title="Permanent link">&para;</a></h3>
<p>Expressions that evaluate to a <a href="./../types/#natives">native type</a> can be called
from Céu.</p>
<p>If a call passes or returns pointers, it may require an accompanying
<a href="#resources-finalization">finalization statement</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">// all expressions below evaluate to a native type and can be called

_printf(&quot;Hello World!\n&quot;);

var _t f = &lt;...&gt;;
f();

var _s s = &lt;...&gt;;
s.f();
</code></pre>

<!--
`TODO: ex. pointer return`
-->

<h3 id="resources-finalization">Resources &amp; Finalization<a class="headerlink" href="#resources-finalization" title="Permanent link">&para;</a></h3>
<p>A finalization statement unconditionally executes a series of statements when
its associated block terminates or is aborted.</p>
<p>Céu tracks the interaction of native calls with pointers and requires 
<code>finalize</code> clauses to accompany the calls:</p>
<ul>
<li>If Céu <strong>passes</strong> a pointer to a native call, the pointer represents a
  <strong>local resource</strong> that requires finalization.
  Finalization executes when the block of the local resource goes out of scope.</li>
<li>If Céu <strong>receives</strong> a pointer from a native call return, the pointer
  represents an <strong>external resource</strong> that requires finalization.
  Finalization executes when the block of the receiving pointer goes out of
  scope.</li>
</ul>
<p>In both cases, the program does not compile without the <code>finalize</code> statement.</p>
<p>A <code>finalize</code> cannot contain
<a href="#synchronous-control-statements">synchronous control statements</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">// Local resource finalization
watching &lt;...&gt; do
    var _buffer_t msg;
    &lt;...&gt;                       // prepares msg
    do
        _send_request(&amp;&amp;msg);
    finalize with
        _send_cancel(&amp;&amp;msg);
    end
    await SEND_ACK;             // transmission is complete
end
</code></pre>

<p>In the example above, the local variable <code>msg</code> is an internal resource passed
as a pointer to <code>_send_request</code>, which is an asynchronous call that transmits
the buffer in the background.
If the enclosing <code>watching</code> aborts before awaking from the <code>await SEND_ACK</code>,
the local <code>msg</code> goes out of scope and the external transmission would hold a
<em>dangling pointer</em>.
The <code>finalize</code> ensures that <code>_send_cancel</code> also aborts the transmission.</p>
<pre><code class="ceu">// External resource finalization
watching &lt;...&gt; do
    var&amp;? _FILE f = &amp;_fopen(&lt;...&gt;) finalize with
                        _fclose(f);
                    end;
    _fwrite(&lt;...&gt;, f);
    await A;
    _fwrite(&lt;...&gt;, f);
end
</code></pre>

<p>In the example above, the call to <code>_fopen</code> returns an external file resource as
a pointer.
If the enclosing <code>watching</code> aborts before awaking from the <code>await A</code>, the file
would remain open as a <em>memory leak</em>.
The <code>finalize</code> ensures that <code>_fclose</code> closes the file properly.</p>
<p>To access an external resource from Céu requires an
<a href="#alias-assignment">alias assignment</a> to a
<a href="./../storage_entities/#aliases">variable alias</a>.
If the external call returns <code>NULL</code> and the variable is an option alias
<code>var&amp;?</code>, the alias remains unbounded.
If the variable is an alias <code>var&amp;</code>, the assigment raises a runtime error.</p>
<p><em>Note: the compiler only forces the programmer to write finalization clauses,
       but cannot check if they handle the resource properly.</em></p>
<p><a href="#native-declaration">Declaration</a> and <a href="./../expressions/#modifiers">expression</a>
modifiers may suppress the requirement for finalization in calls:</p>
<ul>
<li><code>nohold</code> modifiers or <code>/nohold</code> typecasts make passing pointers safe.</li>
<li><code>pure</code>   modifiers or <code>/pure</code>   typecasts make passing pointers and returning
                                  pointers safe.</li>
<li><code>/plain</code> typecasts make return values safe.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">// &quot;_free&quot; does not retain &quot;ptr&quot;
native/nohold _free;
_free(ptr);
// or
(_free as /nohold)(ptr);
</code></pre>

<pre><code class="ceu">// &quot;_strchr&quot; does retain &quot;ptr&quot; or allocates resources
native/pure _strchr;
var _char&amp;&amp; found = _strchr(ptr);
// or
var _char&amp;&amp; found = (_strchr as /pure)(ptr);
</code></pre>

<pre><code class="ceu">// &quot;_f&quot; returns a non-pointer type
var _tp v = _f() as /plain;
</code></pre>

<h2 id="lua-integration">Lua Integration<a class="headerlink" href="#lua-integration" title="Permanent link">&para;</a></h2>
<p>Céu provides <a href="#lua-state">Lua states</a> to delimit the effects of inlined
<a href="#lua-statement">Lua statements</a>.
Lua statements transfer execution to the Lua runtime, losing the guarantees of
the <a href="./../#synchronous-execution-model">synchronous model</a>:</p>
<pre><code class="ceu">Lua_State ::= lua `[´ [Exp] `]´ do
                 Block
              end
Lua_Stmts ::= `[´ {`=´} `[´
                  { {&lt;code in Lua&gt; | `@´ (`(´Exp`)´|Exp)} }   /* `@@´ escapes to `@´ */
              `]´ {`=´} `]´
</code></pre>

<p>Programs have an implicit enclosing <em>global Lua state</em> which all orphan
statements apply.</p>
<h3 id="lua-state">Lua State<a class="headerlink" href="#lua-state" title="Permanent link">&para;</a></h3>
<p>A Lua state creates an isolated state for inlined
<a href="#lua-statement">Lua statements</a>.</p>
<p>Example:</p>
<pre><code class="ceu">// &quot;v&quot; is not shared between the two statements
par do
    // global Lua state
    [[ v = 0 ]];
    var int v = 0;
    every 1s do
        [[print('Lua 1', v, @v) ]];
        v = v + 1;
        [[ v = v + 1 ]];
    end
with
    // local Lua state
    lua[] do
        [[ v = 0 ]];
        var int v = 0;
        every 1s do
            [[print('Lua 2', v, @v) ]];
            v = v + 1;
            [[ v = v + 1 ]];
        end
    end
end
</code></pre>

<p><code>TODO: dynamic scope, assignment/error, [dim]</code></p>
<h3 id="lua-statement">Lua Statement<a class="headerlink" href="#lua-statement" title="Permanent link">&para;</a></h3>
<p>The contents of Lua statements in between <code>[[</code> and <code>]]</code> are inlined in the
program.</p>
<p>Like <a href="#native-statement">native statements</a>, Lua statements support
interpolation of expressions in Céu which are expanded when preceded by a <code>@</code>.</p>
<p>Lua statements only affect the <a href="#lua-state">Lua state</a> in which they are embedded.</p>
<p>If a Lua statement is used in an <a href="#assignments">assignment</a>, it is evaluated as
an expression that either satisfies the destination or generates a runtime
error.
The list that follows specifies the <em>Céu destination</em> and expected
<em>Lua source</em>:</p>
<ul>
<li>a <a href="./../types/#primitives">boolean</a> <a href="./../storage_entities/#variables">variable</a>
    expects a <code>boolean</code> value</li>
<li>a <a href="./../types/#primitives">numeric</a> <a href="./../storage_entities/#variables">variable</a>
    expects a <code>number</code> value</li>
<li>a <a href="./../storage_entities/#pointers">pointer</a> <a href="./../storage_entities/#variables">variable</a>
    expects a <code>lightuserdata</code> value</li>
<li>a <a href="./../types/#primitives">byte</a> <a href="./../storage_entities/#vectors">vector</a>
    expects a <code>string</code> value</li>
</ul>
<p><code>TODO: lua state captures errors</code></p>
<p>Examples:</p>
<pre><code class="ceu">var int v_ceu = 10;
[[
    v_lua = @v_ceu * 2          -- yields 20
]]
v_ceu = [[ v_lua + @v_ceu ]];   // yields 30
[[
    print(@v_ceu)               -- prints 30
]]
</code></pre>

<h2 id="abstractions">Abstractions<a class="headerlink" href="#abstractions" title="Permanent link">&para;</a></h2>
<p>Céu supports reuse with <code>data</code> declarations to define new types, and <code>code</code>
declarations to define new subprograms.</p>
<p>Declarations are subject to <a href="./../storage_entities/#lexical-scope">lexical scope</a>.</p>
<h3 id="data">Data<a class="headerlink" href="#data" title="Permanent link">&para;</a></h3>
<p>A <code>data</code> declaration creates a new data type:</p>
<pre><code class="ceu">Data ::= data ID_abs [as (nothing|Exp)] [ with
             (Var|Vec|Pool|Int) `;´ { (Var|Vec|Pool|Int) `;´ }
         end

Data_Cons ::= (val|new) Abs_Cons
Abs_Cons  ::= [Loc `.´] ID_abs `(´ LIST(Data_Cons|Vec_Cons|Exp|`_´) `)´
</code></pre>

<p>A declaration may pack fields with
<a href="#declarations">storage declarations</a> which become publicly
accessible in the new type.
Field declarations may <a href="#assignments">assign</a> default values for
uninitialized instances.</p>
<p>Data types can form hierarchies using dots (<code>.</code>) in identifiers:</p>
<ul>
<li>An isolated identifier such as <code>A</code> makes <code>A</code> a base type.</li>
<li>A dotted identifier such as <code>A.B</code> makes <code>A.B</code> a subtype of its supertype <code>A</code>.</li>
</ul>
<p>A subtype inherits all fields from its supertype.</p>
<p>The optional modifier <code>as</code> expects the keyword <code>nothing</code> or a constant
expression of type <code>int</code>:</p>
<ul>
<li><code>nothing</code>: the <code>data</code> cannot be instantiated.</li>
<li><em>constant expression</em>: <a href="./../expressions/#type-cast">typecasting</a> a value of
                         the type to <code>int</code> evaluates to the specified
                         enumeration expression.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">data Rect with
    var int x, y, h, w;
    var int z = 0;
end
var Rect r = val Rect(10,10, 100,100, _);  // &quot;r.z&quot; defaults to 0
</code></pre>

<pre><code class="ceu">data Dir       as nothing;  // &quot;Dir&quot; is a base type and cannot be intantiated
data Dir.Right as  1;       // &quot;Dir.Right&quot; is a subtype of &quot;Dir&quot;
data Dir.Left  as -1;       // &quot;Dir.Left&quot;  is a subtype of &quot;Dir&quot;
var  Dir dir = &lt;...&gt;;       // receives one of &quot;Dir.Right&quot; or &quot;Dir.Left&quot;
escape (dir as int);        // returns 1 or -1
</code></pre>

<p><code>TODO: new, pool, recursive types</code></p>
<h4 id="data-constructor">Data Constructor<a class="headerlink" href="#data-constructor" title="Permanent link">&para;</a></h4>
<p>A new data value is created in the contexts that follow:</p>
<ul>
<li>Prefixed by the keyword <code>val</code> in an <a href="#assignments">assignment</a> to a variable.</li>
<li>As an argument to a <a href="#code-invocation"><code>code</code> invocation</a>.</li>
<li>Nested as an argument in a <code>data</code> creation (i.e., a <code>data</code> that contains
  another <code>data</code>).</li>
</ul>
<p>In all cases, the arguments are copied to the destination.
The destination must be a plain declaration (i.e., not an alias or pointer).</p>
<p>The constructor uses the <code>data</code> identifier followed by a list of arguments
matching the fields of the type.</p>
<p>Variables of the exact same type can be copied in <a href="#assignments">assignments</a>.</p>
<p>For assignments from a subtype to a supertype, the rules are as follows:</p>
<ul>
<li><a href="#copy-assignment">Copy assignments</a><ul>
<li>plain values: only if the subtype contains no extra fields</li>
<li>pointers: allowed</li>
</ul>
</li>
<li><a href="#alias-assignment">Alias assignment</a>: allowed.</li>
</ul>
<pre><code class="ceu">data Object with
    var Rect rect;
    var Dir  dir;
end
var Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());
</code></pre>

<pre><code class="ceu">var Object o2 = o1;         // makes a deep copy of all fields from &quot;o1&quot; to &quot;o2&quot;
</code></pre>

<h3 id="code">Code<a class="headerlink" href="#code" title="Permanent link">&para;</a></h3>
<p>The <code>code/tight</code> and <code>code/await</code> declarations specify new subprograms that can
be invoked from arbitrary points in programs:</p>
<pre><code class="ceu">// prototype declaration
Code_Tight ::= code/tight Mods ID_abs `(´ Params `)´ `-&gt;´ Type
Code_Await ::= code/await Mods ID_abs `(´ Params `)´
                                        [ `-&gt;´ `(´ Params `)´ ]
                                            `-&gt;´ (Type | NEVER)
                    [ throws LIST(ID_abs) ]
Params ::= none | LIST(Var|Vec|Pool|Int)

// full declaration
Code_Impl ::= (Code_Tight | Code_Await) do
                  Block
              end

// invocation
Code_Call  ::= call  Mods Abs_Cons
Code_Await ::= await Mods Abs_Cons
Code_Spawn ::= spawn Mods Abs_Cons [in Loc]
Code_Kill  ::= kill Loc [ `(` Exp `)` ]

Mods ::= [`/´dynamic | `/´static] [`/´recursive]
</code></pre>

<p>A <code>code/tight</code> is a subprogram that cannot contain
<a href="#synchronous-control-statements">synchronous control statements</a> and its body
runs to completion in the current <a href="./../#internal-reactions">internal reaction</a>.</p>
<p>A <code>code/await</code> is a subprogram with no restrictions (e.g., it can manipulate
events and use parallel compositions) and its body execution may outlive
multiple reactions.</p>
<p>A <em>prototype declaration</em> specifies the interface parameters of the
abstraction which invocations must satisfy.
A <em>full declaration</em> (aka <em>definition</em>) also specifies an implementation
with a block of code.
An <em>invocation</em> specifies the name of the code abstraction and arguments
matching its declaration.</p>
<p>Declarations can be nested.
A nested declaration is not visible outside its enclosing declaration.
The body of a nested declaration may access entities from its enclosing
declarations with the prefix <a href="./../expressions/#outer"><code>outer</code></a>.</p>
<p>To support recursive abstractions, a code invocation can appear before the
implementation is known, but after the prototype declaration.
In this case, the declaration must use the modifier <code>/recursive</code>.</p>
<p>Examples:</p>
<pre><code class="ceu">code/tight Absolute (var int v) -&gt; int do   // declares the prototype for &quot;Absolute&quot;
    if v &gt; 0 then                           // implements the behavior
        escape  v;
    else
        escape -v;
    end
end
var int abs = call Absolute(-10);           // invokes &quot;Absolute&quot; (yields 10)
</code></pre>

<pre><code class="ceu">code/await Hello_World (none) -&gt; NEVER do
    every 1s do
        _printf(&quot;Hello World!\n&quot;);  // prints &quot;Hello World!&quot; every second
    end
end
await Hello_World();                // never awakes
</code></pre>

<pre><code class="ceu">code/tight/recursive Fat (var int v) -&gt; int;    // &quot;Fat&quot; is a recursive code
code/tight/recursive Fat (var int v) -&gt; int do
    if v &gt; 1 then
        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration
    else
        escape 1;
    end
end
var int fat = call/recursive Fat(10);           // invokes &quot;Fat&quot; (yields 3628800)
</code></pre>

<p><code>TODO: hold</code></p>
<h4 id="code-declaration">Code Declaration<a class="headerlink" href="#code-declaration" title="Permanent link">&para;</a></h4>
<p>Code abstractions specify a list of input parameters in between the symbols
<code>(</code> and <code>)</code>.
Each parameter specifies an <a href="./../storage_entities/#entity-classes">entity class</a>
with modifiers, a type and an identifier.
A <code>none</code> list specifies that the abstraction has no parameters.</p>
<p>Code abstractions also specify an output return type.
A <code>code/await</code> may use <code>NEVER</code> as output to indicate that it never returns.</p>
<p>A <code>code/await</code> may also specify an optional <em>public field list</em>, which are
local storage entities living in the outermost scope of the abstraction body.
These entities are visible to the invoking context, which may
<a href="#code-references">access</a> them while the abstraction executes.
Likewise, nested code declarations in the outermost scope, known as methods,
are also visible to the invoking context.</p>
<p><code>TODO: throws</code></p>
<!--
- The invoker passes a list of unbound aliases to the code.
- The code [binds](#alias-assignment) the aliases to the local resources before
  any [synchronous control statement](#synchronous-control-statements) executes.

Examples:


wzxhzdk:85

-->

<h4 id="code-invocation">Code Invocation<a class="headerlink" href="#code-invocation" title="Permanent link">&para;</a></h4>
<p>A <code>code/tight</code> is invoked with the keyword <code>call</code> followed by the abstraction
name and list of arguments.
A <code>code/await</code> is invoked with the keywords <code>await</code> or <code>spawn</code> followed by the
abstraction name and list of arguments.</p>
<p>The list of arguments must satisfy the list of parameters in the
<a href="#code-declaration">code declaration</a>.</p>
<p>The <code>call</code> and <code>await</code> invocations suspend the current trail and transfer
control to the code abstraction.
The invoking point only resumes after the abstraction terminates and evaluates
to a value of its return type which can be captured with an optional
<a href="#assignment">assignment</a>.</p>
<p>The <code>spawn</code> invocation also suspends and transfers control to the code
abstraction.
However, as soon as the abstraction becomes idle (or terminates), the invoking
point resumes.
This makes the invocation point and abstraction to execute concurrently.</p>
<p>The <code>spawn</code> invocation evaluates to a <a href="#code-references">reference</a>
representing the instance and can be captured with an optional
<a href="#assignment">assignment</a>.
The alias must be an <a href="./../storage_entities/#aliases">option alias variable</a> of
the same type of the code abstraction.
If the abstraction never terminates (i.e., return type is <code>NEVER</code>), the
variable may be a simple alias.
If the <code>spawn</code> fails (e.g., lack of memory) the option alias variable is unset.
In the case of a simple alias, the assignment raises a runtime error.</p>
<p>The <code>spawn</code> invocation also accepts an optional <a href="#pools">pool</a> which provides
storage and scope for invoked abstractions.
When the pool goes out of scope, all invoked abstractions residing in that pool
are aborted.
If the <code>spawn</code> omits the pool, the invocation always succeed and has the same
scope as the invoking point: when the enclosing block terminates, the invoked
code is also aborted.</p>
<p><code>TODO: kill</code></p>
<h4 id="code-references">Code References<a class="headerlink" href="#code-references" title="Permanent link">&para;</a></h4>
<p>The <code>spawn</code> <a href="#code-invocation">invocation</a> and the control variable of
<a href="#pool-iterator">pool iterators</a> evaluate to a reference as an
<a href="./../storage_entities/#aliases">option alias</a> to an abstraction instance.
If the instance terminates at any time, the option variable is automatically
unset.</p>
<p>A reference provides <a href="./../expressions/#fields">access</a> to the public fields and
methods of the instance.</p>
<p>Examples:</p>
<pre><code class="ceu">code/await My_Code (var int x) -&gt; (var int y) -&gt; NEVER do
    y = x;                              // &quot;y&quot; is a public field

    code/tight Get_X (none) -&gt; int do   // &quot;Get_X&quot; is a public method
        escape outer.x;
    end

    await FOREVER;
end

var&amp; My_Code c = spawn My_Code(10);
_printf(&quot;y=%d, x=%d\n&quot;, c.y, c.Get_X());    // prints &quot;y=10, x=10&quot;
</code></pre>

<h4 id="dynamic-dispatching">Dynamic Dispatching<a class="headerlink" href="#dynamic-dispatching" title="Permanent link">&para;</a></h4>
<p>Céu supports dynamic code dispatching based on multiple parameters.</p>
<p>The modifier <code>/dynamic</code> in a declaration specifies that the code is dynamically
dispatched.
A dynamic code must have at least one <code>dynamic</code> parameter.
Also, all dynamic parameters must be pointers or aliases to a
<a href="#data">data type</a> in some hierarchy.</p>
<p>A dynamic declaration requires other compatible dynamic declarations with the
same name, modifiers, parameters, and return type.
The exceptions are the <code>dynamic</code> parameters, which must be in the same
hierarchy of their corresponding parameters in other declarations.</p>
<p>To determine which declaration to execute during runtime, the actual argument
runtime type is checked against the first formal <code>dynamic</code> parameter of each
declaration.
The declaration with the most specific type matching the argument wins.
In the case of a tie, the next dynamic parameter is checked.</p>
<p>A <em>catchall</em> declaration with the most general dynamic types must always be
provided.</p>
<p>If the argument is explicitly <a href="./../expressions/#type-cast">typecast</a> to a
supertype, then dispatching considers that type instead.</p>
<p>Example:</p>
<pre><code class="ceu">data Media as nothing;
data Media.Audio     with &lt;...&gt; end
data Media.Video     with &lt;...&gt; end
data Media.Video.Avi with &lt;...&gt; end

code/await/dynamic Play (dynamic var&amp; Media media) -&gt; none do
    _assert(0);             // never dispatched
end
code/await/dynamic Play (dynamic var&amp; Media.Audio media) -&gt; none do
    &lt;...&gt;                   // plays an audio
end
code/await/dynamic Play (dynamic var&amp; Media.Video media) -&gt; none do
    &lt;...&gt;                   // plays a video
end
code/await/dynamic Play (dynamic var&amp; Media.Video.Avi media) -&gt; none do
    &lt;...&gt;                                   // prepare the avi video
    await/dynamic Play(&amp;m as Media.Video);  // dispatches the supertype
end

var&amp; Media m = &lt;...&gt;;       // receives one of &quot;Media.Audio&quot; or &quot;Media.Video&quot;
await/dynamic Play(&amp;m);     // dispatches the appropriate subprogram to play the media
</code></pre>

<h2 id="synchronous-control-statements">Synchronous Control Statements<a class="headerlink" href="#synchronous-control-statements" title="Permanent link">&para;</a></h2>
<p>The <em>synchronous control statements</em> which follow cannot appear in
<a href="#event-iterator">event iterators</a>,
<a href="#pool-iterator">pool iterators</a>,
<a href="#asynchronous-execution">asynchronous execution</a>,
<a href="#resources-finalization">finalization</a>,
and
<a href="#code">tight code abstractions</a>:
<code>await</code>, <code>spawn</code>, <code>emit</code> (internal events), <code>every</code>, <code>finalize</code>, <code>pause/if</code>,
<code>par</code>, <code>par/and</code>, <code>par/or</code>, and <code>watching</code>.</p>
<p>As exceptions, an <code>every</code> can <code>emit</code> internal events, and a <code>code/tight</code> can
contain empty <code>finalize</code> statements.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../expressions/" class="btn btn-neutral float-right" title="Locations & Expressions">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../storage_entities/" class="btn btn-neutral" title="Storage Entities"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../storage_entities/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../expressions/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
