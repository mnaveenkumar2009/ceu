{
    "docs": [
        {
            "location": "/",
            "text": "Overview\n\u00b6\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n with the following\ngeneral characteristics:\n\n\n\n\nReactive\n:    code executes in reactions to events.\n\n\nStructured\n:  code uses structured control-flow mechanisms, such as \nspawn\n\n                 and \nawait\n (to create and suspend lines of execution).\n\n\nSynchronous\n: event reactions run atomically and to completion on each line\n                 of execution.\n\n\n\n\n\n\n\nThe lines of execution in C\u00e9u, known as \ntrails\n, react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as an\nunique and global time reference.\n\n\nThe example in C\u00e9u that follows blinks a LED every second and terminates on a\nbutton press:\n\n\ninput  none   BUTTON;\noutput on/off LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(on);\n        await 1s;\n        emit LED(off);\n    end\nend\n\n\n\n\nThe synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no preemption or real parallelism at the synchronous\ncore of the language (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e., \nlocks\n or\n\nqueues\n).\n\n\nC\u00e9u provides static memory management based on lexical scope and does not\nrequire a garbage collector.\n\n\nC\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.\n\n\nEnvironments\n\u00b6\n\n\nAs a reactive language, C\u00e9u depends on an external host platform, known as an\n\nenvironment\n, which exposes \ninput\n and \noutput\n events programs can use.\n\n\nAn environment senses the world and broadcasts \ninput\n events to programs.\nIt also intercepts programs signalling \noutput\n events to actuate in the\nworld:\n\n\n\n\nAs examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.\n\n\n\n\n\nSynchronous Execution Model\n\u00b6\n\n\nC\u00e9u is grounded on a precise notion of \nlogical time\n (as opposed to\n\nphysical\n) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n   single trail.\n\n\nActive trails, one after another, execute until they await or terminate.\n   This step is named a \nreaction chain\n, and always runs in bounded time.\n   New trails can be created with\n   \nparallel compositions\n.\n\n\nThe program goes idle.\n\n\nOn the occurrence of a new input event, \nall\n trails awaiting that event\n   awake.\n   It then goes to step 2.\n\n\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of input events.\nA reaction chain, aka \nexternal reaction\n, is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram that follow illustrate the behavior of the scheduler of\nC\u00e9u:\n\n\n 1:  input none A;\n 2:  input none B;\n 3:  input none C;\n 4:  par/and do\n 5:      // trail 1\n 6:      <...>          // a `<...>` represents non-awaiting statements\n 7:      await A;       // (e.g., assignments and native calls)\n 8:      <...>\n 9:  with\n10:      // trail 2\n11:      <...>\n12:      await B;\n13:      <...>\n14:  with\n15:      // trail 3\n16:      <...>\n17:      await A;\n18:      <...>\n19:      await B;\n20:      par/and do\n21:          // trail 3\n22:          <...>\n23:      with\n24:          // trail 4\n25:          <...>\n26:      end\n27:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 7);\n\n\ntrail-2\n executes up to the \nawait B\n (line 12);\n\n\ntrail-3\n executes up to the \nawait A\n (line 17).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until a new event occurs (\nt1=A\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 8);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 19).\n\n\n\n\nNote that during the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n\noccur which are all enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it becomes the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nSince a \npar/and\n rejoins after all trails terminate, the program also\nterminates and does not react to the pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).\n\n\n\n\n\nParallel Compositions and Abortion\n\u00b6\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, it is important to note that parallel compositions support\n\nawaiting in parallel\n, rather than \nexecuting in parallel\n (see\n\nAsynchronous Threads\n for real parallelism support).\n\n\n\nBounded Execution\n\u00b6\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, which are unbounded loops that do not await.\n\n\nIn the example that follow, if the condition is false, the true branch of the\n\nif\n never executes, resulting in a tight loop:\n\n\nloop do\n    if <cond> then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u warns about tight loops in programs at compile time.\nFor computationally-intensive algorithms that require unrestricted loops (e.g.,\ncryptography, image processing), C\u00e9u provides\n\nAsynchronous Execution\n.\n\n\nDeterministic Execution\n\u00b6\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)\n\n\nInternal Reactions\n\u00b6\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nawait\n an internal event to suspend it.\nThen, another trail can \nemit\n and broadcast an event, awaking all trails\nawaiting that event.\n\n\nUnlike input events, multiple internal events can coexist during an external\nreaction.\nAn \nemit\n starts a new \ninternal reaction\n in the program which relies on a\nruntime stack:\n\n\n\n\nThe \nemit\n suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute in sequence\n    (see \nrule 2\n for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with \nrule 1\n.\n\n\nThe top of the stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nThe program as follow illustrates the behavior of internal reactions in C\u00e9u:\n\n\n1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n7:      emit e;\n8:  end\n\n\n\n\nThe program starts in the boot reaction with an empty stack and forks into the\nthree trails.\nRespecting the lexical order, the first two trails \nawait\n and the third trail\nexecutes:\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 7) starts an internal reaction (\nstack=[7]\n).\n\n\nThe \nawait e\n in \ntrail-1\n awakes (line 2) and then the \nemit f\n (line 3)\n  starts another internal reaction (\nstack=[7,3]\n).\n\n\nThe \nawait f\n in \ntrail-2\n awakes and terminates the trail (line 5).\n  Since no other trails are awaiting \nf\n, the current internal reaction\n  terminates, resuming and popping the top of the stack (\nstack=[7]\n).\n\n\nThe \nemit f\n resumes in \ntrail-1\n and terminates the trail (line 3).\n  The current internal reaction terminates, resuming and popping the top of the\n  stack (\nstack=[]\n).\n\n\nThe \nemit e\n resumes in \ntrail-3\n and terminates the trail (line 7).\n  Finally, the \npar/and\n rejoins and the program terminates.",
            "title": "Overview"
        },
        {
            "location": "/#overview",
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming  with the following\ngeneral characteristics:   Reactive :    code executes in reactions to events.  Structured :  code uses structured control-flow mechanisms, such as  spawn \n                 and  await  (to create and suspend lines of execution).  Synchronous : event reactions run atomically and to completion on each line\n                 of execution.    The lines of execution in C\u00e9u, known as  trails , react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as an\nunique and global time reference.  The example in C\u00e9u that follows blinks a LED every second and terminates on a\nbutton press:  input  none   BUTTON;\noutput on/off LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(on);\n        await 1s;\n        emit LED(off);\n    end\nend  The synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no preemption or real parallelism at the synchronous\ncore of the language (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e.,  locks  or queues ).  C\u00e9u provides static memory management based on lexical scope and does not\nrequire a garbage collector.  C\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.  C\u00e9u is  free software .",
            "title": "Overview"
        },
        {
            "location": "/#environments",
            "text": "As a reactive language, C\u00e9u depends on an external host platform, known as an environment , which exposes  input  and  output  events programs can use.  An environment senses the world and broadcasts  input  events to programs.\nIt also intercepts programs signalling  output  events to actuate in the\nworld:   As examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.",
            "title": "Environments"
        },
        {
            "location": "/#synchronous-execution-model",
            "text": "C\u00e9u is grounded on a precise notion of  logical time  (as opposed to physical ) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n   single trail.  Active trails, one after another, execute until they await or terminate.\n   This step is named a  reaction chain , and always runs in bounded time.\n   New trails can be created with\n    parallel compositions .  The program goes idle.  On the occurrence of a new input event,  all  trails awaiting that event\n   awake.\n   It then goes to step 2.   The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of input events.\nA reaction chain, aka  external reaction , is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram that follow illustrate the behavior of the scheduler of\nC\u00e9u:   1:  input none A;\n 2:  input none B;\n 3:  input none C;\n 4:  par/and do\n 5:      // trail 1\n 6:      <...>          // a `<...>` represents non-awaiting statements\n 7:      await A;       // (e.g., assignments and native calls)\n 8:      <...>\n 9:  with\n10:      // trail 2\n11:      <...>\n12:      await B;\n13:      <...>\n14:  with\n15:      // trail 3\n16:      <...>\n17:      await A;\n18:      <...>\n19:      await B;\n20:      par/and do\n21:          // trail 3\n22:          <...>\n23:      with\n24:          // trail 4\n25:          <...>\n26:      end\n27:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 7);  trail-2  executes up to the  await B  (line 12);  trail-3  executes up to the  await A  (line 17).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until a new event occurs ( t1=A  in the diagram):   trail-1  awakes, executes and terminates (line 8);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 19).   Note that during the reaction  t1 , new instances of events  A ,  B , and  C \noccur which are all enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it becomes the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   Since a  par/and  rejoins after all trails terminate, the program also\nterminates and does not react to the pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).",
            "title": "Synchronous Execution Model"
        },
        {
            "location": "/#parallel-compositions-and-abortion",
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;  a  par  never rejoins, even if all trails terminate.   As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, it is important to note that parallel compositions support awaiting in parallel , rather than  executing in parallel  (see Asynchronous Threads  for real parallelism support).",
            "title": "Parallel Compositions and Abortion"
        },
        {
            "location": "/#bounded-execution",
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , which are unbounded loops that do not await.  In the example that follow, if the condition is false, the true branch of the if  never executes, resulting in a tight loop:  loop do\n    if <cond> then\n        break;\n    end\nend  C\u00e9u warns about tight loops in programs at compile time.\nFor computationally-intensive algorithms that require unrestricted loops (e.g.,\ncryptography, image processing), C\u00e9u provides Asynchronous Execution .",
            "title": "Bounded Execution"
        },
        {
            "location": "/#deterministic-execution",
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)",
            "title": "Deterministic Execution"
        },
        {
            "location": "/#internal-reactions",
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  await  an internal event to suspend it.\nThen, another trail can  emit  and broadcast an event, awaking all trails\nawaiting that event.  Unlike input events, multiple internal events can coexist during an external\nreaction.\nAn  emit  starts a new  internal reaction  in the program which relies on a\nruntime stack:   The  emit  suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute in sequence\n    (see  rule 2  for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with  rule 1 .  The top of the stack is popped and the last emitting trail resumes execution\n    from its continuation.   The program as follow illustrates the behavior of internal reactions in C\u00e9u:  1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n7:      emit e;\n8:  end  The program starts in the boot reaction with an empty stack and forks into the\nthree trails.\nRespecting the lexical order, the first two trails  await  and the third trail\nexecutes:   The  emit e  in  trail-3  (line 7) starts an internal reaction ( stack=[7] ).  The  await e  in  trail-1  awakes (line 2) and then the  emit f  (line 3)\n  starts another internal reaction ( stack=[7,3] ).  The  await f  in  trail-2  awakes and terminates the trail (line 5).\n  Since no other trails are awaiting  f , the current internal reaction\n  terminates, resuming and popping the top of the stack ( stack=[7] ).  The  emit f  resumes in  trail-1  and terminates the trail (line 3).\n  The current internal reaction terminates, resuming and popping the top of the\n  stack ( stack=[] ).  The  emit e  resumes in  trail-3  and terminates the trail (line 7).\n  Finally, the  par/and  rejoins and the program terminates.",
            "title": "Internal Reactions"
        },
        {
            "location": "/lexical_rules/",
            "text": "Lexical Rules\n\u00b6\n\n\n\n\n\nKeywords\n\u00b6\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g.,\nfor variables and events):\n\n\n    and             as              async           atomic          await\n\n    bool            break           byte            call            code\n\n    const           continue        data            deterministic   do\n\n    dynamic         else            emit            end             escape\n\n    event           every           false           finalize        FOREVER\n\n    hold            if              in              input           int\n\n    integer         is              isr             kill            lock\n\n    loop            lua             native          NEVER           new\n\n    no              nohold          none            not             nothing\n\n    null            off             on              or              outer\n\n    output          par             pause           plain           pool\n\n    pos             pre             pure            r32             r64\n\n    real            recursive       request         resume          s16\n\n    s32             s64             s8              sizeof          spawn\n\n    ssize           static          then            thread          tight\n\n    traverse        true            u16             u32             u64\n\n    u8              uint            until           usize           val\n\n    var             watching        with            yes\n\n\n\n\nTODO: catch, throw, throws\n\n\nIdentifiers\n\u00b6\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n (\nID_type\n), \nvariables\n (\nID_int\n),\n\nvectors\n (\nID_int\n), \npools\n (\nID_int\n), \ninternal events\n (\nID_int\n),\n\nexternal events\n (\nID_ext\n), \ncode abstractions\n (\nID_abs\n),\n\ndata abstractions\n (\nID_abs\n), \nfields\n (\nID_field\n),\n\nnative symbols\n (\nID_nat\n), and \nblock labels\n (\nID_int\n).\n\n\nID       ::= [a-z, A-Z, 0-9, _]+ // a sequence of letters, digits, and underscores\nID_int   ::= ID                  // ID beginning with lowercase\nID_ext   ::= ID                  // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}         // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID                  // ID not beginning with digit\nID_nat   ::= ID                  // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | none\n             | bool  | on/off | yes/no\n             | byte\n             | r32   | r64    | real\n             | s8    | s16    | s32     | s64\n             | u8    | u16    | u32     | u64\n             | int   | uint   | integer\n             | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n abstractions\n\ncreate new \ntypes\n which can be used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \"a\" is a variable, \"int\" is a type\n\nemit e;                       // \"e\" is an internal event\n\nawait I;                      // \"I\" is an external input event\n\nspawn Move();                 // \"Move\" is a code abstraction and a type\n\nvar Rect r;                   // \"Rect\" is a data abstraction and a type\n\nescape r.width;               // \"width\" is a field\n\n_printf(\"hello world!\\n\");    // \"_printf\" is a native symbol\n\n\n\n\nLiterals\n\u00b6\n\n\nC\u00e9u provides literals for \nbooleans\n, \nintegers\n, \nreals\n, \nstrings\n, and\n\nnull pointers\n.\n\n\n\n\n\nBooleans\n\u00b6\n\n\nThe boolean type has only two possible values: \ntrue\n and \nfalse\n.\n\n\nThe boolean values \non\n and \nyes\n are synonymous to \ntrue\n and can be used\ninterchangeably.\nThe boolean values \noff\n and \nno\n are synonymous to \nfalse\n and can be used\ninterchangeably.\n\n\nIntegers\n\u00b6\n\n\nC\u00e9u supports decimal and hexadecimal integers:\n\n\n\n\nDecimals: a sequence of digits (i.e., \n[0-9]+\n).\n\n\nHexadecimals: a sequence of hexadecimal digits (i.e., \n[0-9, a-f, A-F]+\n)\n                prefixed by \n0x\n.\n\n\n\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal\n\n\n\n\nFloats\n\u00b6\n\n\nTODO (like C)\n\n\nStrings\n\u00b6\n\n\nA sequence of characters surrounded by the character \n\"\n is converted into a\n\nnull-terminated string\n, just like in C:\n\n\nExample:\n\n\n_printf(\"Hello World!\\n\");\n\n\n\n\nNull pointer\n\u00b6\n\n\nTODO (like C)\n\n\nComments\n\u00b6\n\n\nC\u00e9u provides C-style comments:\n\n\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\n  Multi-line comments can be nested by using a different number of \n*\n as\n  delimiters.\n\n\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/",
            "title": "Lexical Rules"
        },
        {
            "location": "/lexical_rules/#lexical-rules",
            "text": "",
            "title": "Lexical Rules"
        },
        {
            "location": "/lexical_rules/#keywords",
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g.,\nfor variables and events):      and             as              async           atomic          await\n\n    bool            break           byte            call            code\n\n    const           continue        data            deterministic   do\n\n    dynamic         else            emit            end             escape\n\n    event           every           false           finalize        FOREVER\n\n    hold            if              in              input           int\n\n    integer         is              isr             kill            lock\n\n    loop            lua             native          NEVER           new\n\n    no              nohold          none            not             nothing\n\n    null            off             on              or              outer\n\n    output          par             pause           plain           pool\n\n    pos             pre             pure            r32             r64\n\n    real            recursive       request         resume          s16\n\n    s32             s64             s8              sizeof          spawn\n\n    ssize           static          then            thread          tight\n\n    traverse        true            u16             u32             u64\n\n    u8              uint            until           usize           val\n\n    var             watching        with            yes  TODO: catch, throw, throws",
            "title": "Keywords"
        },
        {
            "location": "/lexical_rules/#identifiers",
            "text": "C\u00e9u uses identifiers to refer to  types  ( ID_type ),  variables  ( ID_int ), vectors  ( ID_int ),  pools  ( ID_int ),  internal events  ( ID_int ), external events  ( ID_ext ),  code abstractions  ( ID_abs ), data abstractions  ( ID_abs ),  fields  ( ID_field ), native symbols  ( ID_nat ), and  block labels  ( ID_int ).  ID       ::= [a-z, A-Z, 0-9, _]+ // a sequence of letters, digits, and underscores\nID_int   ::= ID                  // ID beginning with lowercase\nID_ext   ::= ID                  // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}         // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID                  // ID not beginning with digit\nID_nat   ::= ID                  // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | none\n             | bool  | on/off | yes/no\n             | byte\n             | r32   | r64    | real\n             | s8    | s16    | s32     | s64\n             | u8    | u16    | u32     | u64\n             | int   | uint   | integer\n             | ssize | usize )  Declarations for  code  and  data  abstractions \ncreate new  types  which can be used as type identifiers.  Examples:  var int a;                    // \"a\" is a variable, \"int\" is a type\n\nemit e;                       // \"e\" is an internal event\n\nawait I;                      // \"I\" is an external input event\n\nspawn Move();                 // \"Move\" is a code abstraction and a type\n\nvar Rect r;                   // \"Rect\" is a data abstraction and a type\n\nescape r.width;               // \"width\" is a field\n\n_printf(\"hello world!\\n\");    // \"_printf\" is a native symbol",
            "title": "Identifiers"
        },
        {
            "location": "/lexical_rules/#literals",
            "text": "C\u00e9u provides literals for  booleans ,  integers ,  reals ,  strings , and null pointers .",
            "title": "Literals"
        },
        {
            "location": "/lexical_rules/#booleans",
            "text": "The boolean type has only two possible values:  true  and  false .  The boolean values  on  and  yes  are synonymous to  true  and can be used\ninterchangeably.\nThe boolean values  off  and  no  are synonymous to  false  and can be used\ninterchangeably.",
            "title": "Booleans"
        },
        {
            "location": "/lexical_rules/#integers",
            "text": "C\u00e9u supports decimal and hexadecimal integers:   Decimals: a sequence of digits (i.e.,  [0-9]+ ).  Hexadecimals: a sequence of hexadecimal digits (i.e.,  [0-9, a-f, A-F]+ )\n                prefixed by  0x .    Examples:  // both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal",
            "title": "Integers"
        },
        {
            "location": "/lexical_rules/#floats",
            "text": "TODO (like C)",
            "title": "Floats"
        },
        {
            "location": "/lexical_rules/#strings",
            "text": "A sequence of characters surrounded by the character  \"  is converted into a null-terminated string , just like in C:  Example:  _printf(\"Hello World!\\n\");",
            "title": "Strings"
        },
        {
            "location": "/lexical_rules/#null-pointer",
            "text": "TODO (like C)",
            "title": "Null pointer"
        },
        {
            "location": "/lexical_rules/#comments",
            "text": "C\u00e9u provides C-style comments:   Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\n  Multi-line comments can be nested by using a different number of  *  as\n  delimiters.   Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/",
            "title": "Comments"
        },
        {
            "location": "/types/",
            "text": "Types\n\u00b6\n\n\nC\u00e9u is statically typed, requiring all variables, events, and other\n\nstorage entities\n to be declared before\nthey are used in programs.\n\n\nA type is composed of a \ntype identifier\n,\nfollowed by an optional sequence of \npointer modifiers\n \n&&\n,\nfollowed by an optional \noption modifier\n \n?\n:\n\n\nType ::= ID_type {`&&\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar   u8     v;    // \"v\" is of 8-bit unsigned integer type\nvar   _rect  r;    // \"r\" is of external native type \"rect\"\nvar   Tree   t;    // \"t\" is a data of type \"Tree\"\nvar   int?   ret;  // \"ret\" is either unset or is of integer type\ninput byte&& RECV; // \"RECV\" is an input event carrying a pointer to a \"byte\"\n\n\n\n\nPrimitives\n\u00b6\n\n\nC\u00e9u has the following primitive types:\n\n\nnone               // void type\nbool               // boolean type\non/off             // synonym to bool\nyes/no             // synonym to bool\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ninteger            // synonym to int\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nreal               // platform dependent real\nr32      r64       // 32-bit and 64-bit reals\nssize    usize     // signed and unsigned size types\n\n\n\n\n\n\n\nNatives\n\u00b6\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \"message_t\" is a C type defined in an external library\n\n\n\n\nNative types support \nmodifiers\n to provide\nadditional information to the compiler.\n\n\nAbstractions\n\u00b6\n\n\n\n\n\nSee \nAbstractions\n.\n\n\nModifiers\n\u00b6\n\n\nTypes can be suffixed with the pointer modifier \n&&\n and the option modifier\n\n?\n.\n\n\nPointer\n\u00b6\n\n\nTODO (like in C)\n\n\nTODO cannot cross yielding statements\n\n\nOption\n\u00b6\n\n\nTODO (like \"Maybe\")\n\n\nTODO: _",
            "title": "Types"
        },
        {
            "location": "/types/#types",
            "text": "C\u00e9u is statically typed, requiring all variables, events, and other storage entities  to be declared before\nthey are used in programs.  A type is composed of a  type identifier ,\nfollowed by an optional sequence of  pointer modifiers   && ,\nfollowed by an optional  option modifier   ? :  Type ::= ID_type {`&&\u00b4} [`?\u00b4]  Examples:  var   u8     v;    // \"v\" is of 8-bit unsigned integer type\nvar   _rect  r;    // \"r\" is of external native type \"rect\"\nvar   Tree   t;    // \"t\" is a data of type \"Tree\"\nvar   int?   ret;  // \"ret\" is either unset or is of integer type\ninput byte&& RECV; // \"RECV\" is an input event carrying a pointer to a \"byte\"",
            "title": "Types"
        },
        {
            "location": "/types/#primitives",
            "text": "C\u00e9u has the following primitive types:  none               // void type\nbool               // boolean type\non/off             // synonym to bool\nyes/no             // synonym to bool\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ninteger            // synonym to int\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nreal               // platform dependent real\nr32      r64       // 32-bit and 64-bit reals\nssize    usize     // signed and unsigned size types",
            "title": "Primitives"
        },
        {
            "location": "/types/#natives",
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      // \"message_t\" is a C type defined in an external library  Native types support  modifiers  to provide\nadditional information to the compiler.",
            "title": "Natives"
        },
        {
            "location": "/types/#abstractions",
            "text": "See  Abstractions .",
            "title": "Abstractions"
        },
        {
            "location": "/types/#modifiers",
            "text": "Types can be suffixed with the pointer modifier  &&  and the option modifier ? .",
            "title": "Modifiers"
        },
        {
            "location": "/types/#pointer",
            "text": "TODO (like in C)  TODO cannot cross yielding statements",
            "title": "Pointer"
        },
        {
            "location": "/types/#option",
            "text": "TODO (like \"Maybe\")  TODO: _",
            "title": "Option"
        },
        {
            "location": "/storage_entities/",
            "text": "Storage Entities\n\u00b6\n\n\nStorage entities represent all objects that are stored in memory during\nexecution.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as entity classes.\n\n\nAn \nentity declaration\n consists of an entity\nclass, a \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar    int    v;     // \"v\" is a variable of type \"int\"\nvar[9] byte   buf;   // \"buf\" is a vector with at most 9 values of type \"byte\"\ninput  none&& A;     // \"A\" is an input event that carries values of type \"none&&\"\nevent  bool   e;     // \"e\" is an internal event that carries values of type \"bool\"\npool[] Anim   anims; // \"anims\" is a dynamic \"pool\" of instances of type \"Anim\"\n\n\n\n\nA declaration binds the identifier with a memory location that holds values of\nthe associated type.\n\n\nLexical Scope\n\u00b6\n\n\nStorage entities have lexical scope, i.e., they are visible only in the\n\nblock\n in which they are declared.\n\n\nThe lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.\n\n\nEntity Classes\n\u00b6\n\n\nVariables\n\u00b6\n\n\nA variable in C\u00e9u holds a value of a \ndeclared\n\n\ntype\n that may vary during program execution.\nThe value of a variable can be read in\n\nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\u00b6\n\n\nA vector in C\u00e9u is a dynamic and contiguous collection of variables of the same\ntype.\n\n\nA \nvector declaration\n specifies its type and maximum\nnumber of elements (possibly unlimited).\nThe current length of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\n\n\nIndividual elements of a vector can be accessed through an\n\nindex\n starting from \n0\n.\nC\u00e9u generates an \nerror\n for out-of-bounds vector accesses.\n\n\nExample:\n\n\nvar[9] byte buf = [1,2,3];  // write access\nbuf = buf .. [4];           // write access\nescape buf[1];              // read access (yields 2)\n\n\n\n\nTODO: ring buffers\n\n\nEvents\n\u00b6\n\n\nEvents account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the \nawait\n and\n\nemit\n\nstatements.\nAn \nawait\n halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.\n\n\nUnlike all other entity classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring\nevent carries.\n\n\nNote: \nnone\n is a valid type for signal-only events with no associated values.\n\n\nExample:\n\n\ninput  none I;           // \"I\" is an input event that carries no values\noutput int  O;           // \"O\" is an output event that carries values of type \"int\"\nevent  int  e;           // \"e\" is an internal event that carries values of type \"int\"\npar/and do\n    await I;             // awakes when \"I\" occurs\n    emit e(10);          // broadcasts \"e\" passing 10, awakes the \"await\" below\nwith\n    var int v = await e; // awaits \"e\" assigning the received value to \"v\"\n    emit O(v);           // emits \"O\" back to the environment passing \"v\"\nend\n\n\n\n\nAs described in \nInternal Reactions\n, C\u00e9u supports\nexternal and internal events with different behavior.\n\n\nExternal Events\n\u00b6\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput events\n represent input devices such as a sensor, button, mouse, etc.\n\n\noutput events\n represent output devices such as a LED, motor, screen, etc.\n\n\n\n\nThe availability of external events depends on the\n\nenvironment\n in use.\n\n\nPrograms can \nemit\n output events and \nawait\n input events.\n\n\n\n\n\n\n\n\nInternal Events\n\u00b6\n\n\nInternal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.\n\n\nPrograms can \nemit\n and \nawait\n internal events.\n\n\nPools\n\u00b6\n\n\nA pool is a dynamic container to hold running \ncode abstractions\n.\n\n\nA \npool declaration\n specifies the type of the\nabstraction and maximum number of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through\n\niterators\n.\nNew elements are created with \nspawn\n and are\nremoved automatically when the code execution terminates.\n\n\nExample:\n\n\ncode/await Anim (none) => none do       // defines the \"Anim\" code abstraction\n    <...>                               // body of \"Anim\"\nend\npool[] Anim as;                         // declares an unlimited container for \"Anim\" instances\nloop i in [1->10] do\n    spawn Anim() in as;                 // creates 10 instances of \"Anim\" into \"as\"\nend\n\n\n\n\nWhen a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.\n\n\nTODO: kill\n\n\n\n\n\nLocations\n\u00b6\n\n\nA location (aka \nl-value\n) is a path to a memory position holding a value.\n\n\nThe list that follows summarizes all valid locations:\n\n\n\n\nstorage entity: variable, vector, internal event (but not external), or pool\n\n\nnative expression or symbol\n\n\ndata field\n\n\nvector index\n\n\nvector length \n$\n\n\npointer dereferencing \n*\n\n\noption unwrapping \n!\n\n\n\n\nLocations appear in assignments, event manipulation, iterators, and\nexpressions.\nLocations are detailed in \nLocations and Expressions\n.\n\n\nExamples:\n\n\nemit e(1);          // \"e\" is an internal event\n_UDR = 10;          // \"_UDR\" is a native symbol\nperson.age = 70;    // \"age\" is a field of \"person\"\nvec[0] = $vec;      // \"vec[0]\" is a vector index\n$vec = 1;           // \"$vec\" is a vector length\n*ptr = 1;           // \"ptr\" is a pointer to a variable\na! = 1;             // \"a\" is of an option type\n\n\n\n\nReferences\n\u00b6\n\n\nC\u00e9u supports \naliases\n and \npointers\n as references to entities, aka \nstrong\n\nand \nweak\n references, respectively.\n\n\nAn alias is an alternate view for an entity: after the entity and alias are\nbounded, they are indistinguishable.\n\n\nA pointer is a value that is the address of an entity, providing indirect\naccess to it.\n\n\nAs an analogy with a person's identity,\na family nickname referring to a person is an alias;\na job position referring to a person is a pointer.\n\n\nAliases\n\u00b6\n\n\nC\u00e9u support aliases to all storage entity classes, except external events and\npointer types.\nC\u00e9u also supports option variable aliases which are aliases that may be bounded\nor not.\n\n\nAn alias is declared by suffixing the entity class with the modifier\n\n&\n and is acquired by prefixing an entity identifier with the operator \n&\n.\n\n\nAn alias must have a narrower scope than the entity it refers to.\nThe \nassignment\n to the alias is immutable and must\noccur between its declaration and first access or next\n\nyielding statement\n.\n\n\nExample:\n\n\nvar  int v = 0;\nvar& int a = &v;        // \"a\" is an alias to \"v\"\n...\na = 1;                  // \"a\" and \"v\" are indistinguishable\n_printf(\"%d\\n\", v);     // prints 1\n\n\n\n\nAn option variable alias, declared as \nvar&?\n, serves two purposes:\n\n\n\n\nMap a \nnative resource\n to C\u00e9u.\n  The alias is acquired by prefixing the associated\n  \nnative call\n with the operator \n&\n.\n  Since the allocation may fail, the alias may remain unbounded.\n\n\nHold the result of a \nspawn\n invocation.\n  Since the allocation may fail, the alias may remain unbounded.\n\n\n\n\n\n\n\nAccesses to option variable aliases must always use\n\noption checking or unwrapping\n.\n\n\nTODO: or implicit assert with & declarations\n\n\nExamples:\n\n\nvar&? _FILE f = &_fopen(<...>) finalize with\n                    _fclose(f);\n                end;\nif f? then\n    <...>   // \"f\" is assigned\nelse\n    <...>   // \"f\" is not assigned\nend\n\n\n\n\nvar&? My_Code my_code = spawn My_Code();\nif my_code? then\n    <...>   // \"spawn\" succeeded\nelse\n    <...>   // \"spawn\" failed\nend\n\n\n\n\n\n\n\nPointers\n\u00b6\n\n\nA pointer is declared by suffixing the type with the modifier\n\n&&\n and is acquired by prefixing an entity with the operator \n&&\n.\nApplying the operator \n*\n to a pointer provides indirect access to its\nreferenced entity.\n\n\nExample:\n\n\nvar int   v = 0;\nvar int&& p = &&v;      // \"p\" holds a pointer to \"v\"\n...\n*p = 1;                 // \"p\" provides indirect access to \"v\"\n_printf(\"%d\\n\", v);     // prints 1\n\n\n\n\nThe following restrictions apply to pointers in C\u00e9u:\n\n\n\n\n\n\n\nNo support for pointers to events, vectors, or pools (only variables).\n\n\nA pointer is only accessible between its declaration and the next\n  \nyielding statement\n.",
            "title": "Storage Entities"
        },
        {
            "location": "/storage_entities/#storage-entities",
            "text": "Storage entities represent all objects that are stored in memory during\nexecution.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as entity classes.  An  entity declaration  consists of an entity\nclass, a  type , and an  identifier .  Examples:  var    int    v;     // \"v\" is a variable of type \"int\"\nvar[9] byte   buf;   // \"buf\" is a vector with at most 9 values of type \"byte\"\ninput  none&& A;     // \"A\" is an input event that carries values of type \"none&&\"\nevent  bool   e;     // \"e\" is an internal event that carries values of type \"bool\"\npool[] Anim   anims; // \"anims\" is a dynamic \"pool\" of instances of type \"Anim\"  A declaration binds the identifier with a memory location that holds values of\nthe associated type.",
            "title": "Storage Entities"
        },
        {
            "location": "/storage_entities/#lexical-scope",
            "text": "Storage entities have lexical scope, i.e., they are visible only in the block  in which they are declared.  The lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.",
            "title": "Lexical Scope"
        },
        {
            "location": "/storage_entities/#entity-classes",
            "text": "",
            "title": "Entity Classes"
        },
        {
            "location": "/storage_entities/#variables",
            "text": "A variable in C\u00e9u holds a value of a  declared  type  that may vary during program execution.\nThe value of a variable can be read in expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)",
            "title": "Variables"
        },
        {
            "location": "/storage_entities/#vectors",
            "text": "A vector in C\u00e9u is a dynamic and contiguous collection of variables of the same\ntype.  A  vector declaration  specifies its type and maximum\nnumber of elements (possibly unlimited).\nThe current length of a vector is dynamic and can be accessed through the operator  $ .  Individual elements of a vector can be accessed through an index  starting from  0 .\nC\u00e9u generates an  error  for out-of-bounds vector accesses.  Example:  var[9] byte buf = [1,2,3];  // write access\nbuf = buf .. [4];           // write access\nescape buf[1];              // read access (yields 2)  TODO: ring buffers",
            "title": "Vectors"
        },
        {
            "location": "/storage_entities/#events",
            "text": "Events account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the  await  and emit \nstatements.\nAn  await  halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.  Unlike all other entity classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring\nevent carries.  Note:  none  is a valid type for signal-only events with no associated values.  Example:  input  none I;           // \"I\" is an input event that carries no values\noutput int  O;           // \"O\" is an output event that carries values of type \"int\"\nevent  int  e;           // \"e\" is an internal event that carries values of type \"int\"\npar/and do\n    await I;             // awakes when \"I\" occurs\n    emit e(10);          // broadcasts \"e\" passing 10, awakes the \"await\" below\nwith\n    var int v = await e; // awaits \"e\" assigning the received value to \"v\"\n    emit O(v);           // emits \"O\" back to the environment passing \"v\"\nend  As described in  Internal Reactions , C\u00e9u supports\nexternal and internal events with different behavior.",
            "title": "Events"
        },
        {
            "location": "/storage_entities/#external-events",
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input events  represent input devices such as a sensor, button, mouse, etc.  output events  represent output devices such as a LED, motor, screen, etc.   The availability of external events depends on the environment  in use.  Programs can  emit  output events and  await  input events.",
            "title": "External Events"
        },
        {
            "location": "/storage_entities/#internal-events",
            "text": "Internal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.  Programs can  emit  and  await  internal events.",
            "title": "Internal Events"
        },
        {
            "location": "/storage_entities/#pools",
            "text": "A pool is a dynamic container to hold running  code abstractions .  A  pool declaration  specifies the type of the\nabstraction and maximum number of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through iterators .\nNew elements are created with  spawn  and are\nremoved automatically when the code execution terminates.  Example:  code/await Anim (none) => none do       // defines the \"Anim\" code abstraction\n    <...>                               // body of \"Anim\"\nend\npool[] Anim as;                         // declares an unlimited container for \"Anim\" instances\nloop i in [1->10] do\n    spawn Anim() in as;                 // creates 10 instances of \"Anim\" into \"as\"\nend  When a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.  TODO: kill",
            "title": "Pools"
        },
        {
            "location": "/storage_entities/#locations",
            "text": "A location (aka  l-value ) is a path to a memory position holding a value.  The list that follows summarizes all valid locations:   storage entity: variable, vector, internal event (but not external), or pool  native expression or symbol  data field  vector index  vector length  $  pointer dereferencing  *  option unwrapping  !   Locations appear in assignments, event manipulation, iterators, and\nexpressions.\nLocations are detailed in  Locations and Expressions .  Examples:  emit e(1);          // \"e\" is an internal event\n_UDR = 10;          // \"_UDR\" is a native symbol\nperson.age = 70;    // \"age\" is a field of \"person\"\nvec[0] = $vec;      // \"vec[0]\" is a vector index\n$vec = 1;           // \"$vec\" is a vector length\n*ptr = 1;           // \"ptr\" is a pointer to a variable\na! = 1;             // \"a\" is of an option type",
            "title": "Locations"
        },
        {
            "location": "/storage_entities/#references",
            "text": "C\u00e9u supports  aliases  and  pointers  as references to entities, aka  strong \nand  weak  references, respectively.  An alias is an alternate view for an entity: after the entity and alias are\nbounded, they are indistinguishable.  A pointer is a value that is the address of an entity, providing indirect\naccess to it.  As an analogy with a person's identity,\na family nickname referring to a person is an alias;\na job position referring to a person is a pointer.",
            "title": "References"
        },
        {
            "location": "/storage_entities/#aliases",
            "text": "C\u00e9u support aliases to all storage entity classes, except external events and\npointer types.\nC\u00e9u also supports option variable aliases which are aliases that may be bounded\nor not.  An alias is declared by suffixing the entity class with the modifier &  and is acquired by prefixing an entity identifier with the operator  & .  An alias must have a narrower scope than the entity it refers to.\nThe  assignment  to the alias is immutable and must\noccur between its declaration and first access or next yielding statement .  Example:  var  int v = 0;\nvar& int a = &v;        // \"a\" is an alias to \"v\"\n...\na = 1;                  // \"a\" and \"v\" are indistinguishable\n_printf(\"%d\\n\", v);     // prints 1  An option variable alias, declared as  var&? , serves two purposes:   Map a  native resource  to C\u00e9u.\n  The alias is acquired by prefixing the associated\n   native call  with the operator  & .\n  Since the allocation may fail, the alias may remain unbounded.  Hold the result of a  spawn  invocation.\n  Since the allocation may fail, the alias may remain unbounded.    Accesses to option variable aliases must always use option checking or unwrapping .  TODO: or implicit assert with & declarations  Examples:  var&? _FILE f = &_fopen(<...>) finalize with\n                    _fclose(f);\n                end;\nif f? then\n    <...>   // \"f\" is assigned\nelse\n    <...>   // \"f\" is not assigned\nend  var&? My_Code my_code = spawn My_Code();\nif my_code? then\n    <...>   // \"spawn\" succeeded\nelse\n    <...>   // \"spawn\" failed\nend",
            "title": "Aliases"
        },
        {
            "location": "/storage_entities/#pointers",
            "text": "A pointer is declared by suffixing the type with the modifier &&  and is acquired by prefixing an entity with the operator  && .\nApplying the operator  *  to a pointer provides indirect access to its\nreferenced entity.  Example:  var int   v = 0;\nvar int&& p = &&v;      // \"p\" holds a pointer to \"v\"\n...\n*p = 1;                 // \"p\" provides indirect access to \"v\"\n_printf(\"%d\\n\", v);     // prints 1  The following restrictions apply to pointers in C\u00e9u:    No support for pointers to events, vectors, or pools (only variables).  A pointer is only accessible between its declaration and the next\n   yielding statement .",
            "title": "Pointers"
        },
        {
            "location": "/statements/",
            "text": "Statements\n\u00b6\n\n\nA program in C\u00e9u is a sequence of statements delimited by an implicit enclosing\nblock:\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4}\n\n\n\n\nNote: statements terminated with the \nend\n keyword do not require a\nterminating semicolon.\n\n\nNothing\n\u00b6\n\n\nnothing\n is an innocuous statement:\n\n\nNothing ::= nothing\n\n\n\n\nBlocks\n\u00b6\n\n\nA \nBlock\n delimits a lexical scope for\n\nstorage entities\n\nand\n\nabstractions\n,\nwhich are only visible to statements inside the block.\n\n\nCompound statements (e.g. \ndo-end\n, \nif-then-else\n, \nloops\n, etc.) create new\nblocks and can be nested to an arbitrary level.\n\n\ndo-end\n and \nescape\n\u00b6\n\n\nThe \ndo-end\n statement creates an explicit block.\nThe \nescape\n statement terminates the deepest matching enclosing \ndo-end\n:\n\n\nDo ::= do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]\n\n\n\n\nA \ndo-end\n and \nescape\n accept an optional identifier following the symbol \n/\n.\nAn \nescape\n only matches a \ndo-end\n with the same identifier.\nThe neutral identifier \n_\n in a \ndo-end\n is guaranteed not to match any\n\nescape\n statement.\n\n\nA \ndo-end\n also supports an optional list of identifiers in parenthesis which\nrestricts the visible storage entities inside the block to those matching the\nlist.\nAn empty list hides all storage entities from the enclosing scope.\n\n\nA \ndo-end\n can be \nassigned\n to a variable whose type must be\nmatched by nested \nescape\n statements.\nThe whole block evaluates to the value of a reached \nescape\n.\nIf the variable is of \noption type\n, the \ndo-end\n is allowed\nto terminate without an \nescape\n, otherwise it raises a runtime error.\n\n\nPrograms have an implicit enclosing \ndo-end\n that assigns to a\n\nprogram status variable\n of type \nint\n whose meaning is platform dependent.\n\n\nExamples:\n\n\ndo\n    do/a\n        do/_\n            escape;     // matches line 1\n        end\n        escape/a;       // matches line 2\n    end\nend\n\n\n\n\nvar int a;\nvar int b;\ndo (a)\n    a = 1;\n    b = 2;  // \"b\" is not visible\nend\n\n\n\n\nvar int? v =\n    do\n        if <cnd> then\n            escape 10;  // assigns 10 to \"v\"\n        else\n            nothing;    // \"v\" remains unassigned\n        end\n    end;\n\n\n\n\nescape 0;               // program terminates with a status value of 0\n\n\n\n\npre-do-end\n\u00b6\n\n\nThe \npre-do-end\n statement prepends its statements in the beginning of the\nprogram:\n\n\nPre_Do ::= pre do\n               Block\n           end\n\n\n\n\nAll \npre-do-end\n statements are concatenated together in the order they appear\nand are moved to the beginning of the top-level block, before all other\nstatements.\n\n\nDeclarations\n\u00b6\n\n\nA declaration introduces a \nstorage entity\n\nto the enclosing block.\nAll declarations are subject to \nlexical scope\n.\n\n\nC\u00e9u supports variables, vectors, pools, internal events, and external events:\n\n\n\nVar  ::= var [`&\u00b4|`&?\u00b4] [ `[\u00b4 [Exp [`*`]] `]\u00b4 ] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\nPool ::= pool [`&\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nInt  ::= event [`&\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      |  output (Type | `(\u00b4 LIST([`&\u00b4] Type [ID_int]) `)\u00b4) ID_ext\n            [ do Block end ]\n\nSources ::= /* (see \"Assignments\") */\n\n\n\n\nMost declarations support an initialization \nassignment\n.\n\n\n\n\n\nVariables\n\u00b6\n\n\nA \nvariable\n declaration has an associated\n\ntype\n and can be optionally \ninitialized\n.\nDeclarations can also be\n\naliases or option aliases\n.\n\n\nExamples:\n\n\nvar  int v = 10;    // \"v\" is an integer variable initialized to 10\nvar  int a=0, b=3;  // \"a\" and \"b\" are integer variables initialized to 0 and 3\nvar& int z = &v;    // \"z\" is an alias to \"v\"\n\n\n\n\nVectors\n\u00b6\n\n\nA \nvector\n declaration specifies a\n\ndimension\n between brackets,\nan associated \ntype\n and can be optionally\n\ninitialized\n.\nDeclarations can also be \naliases\n.\n\nTODO: ring buffers\n\n\n\n\n\nExamples:\n\n\nvar int n = 10;\nvar[10] int vs1 = [];    // \"vs1\" is a static vector of 10 elements max\nvar[n]  int vs2 = [];    // \"vs2\" is a dynamic vector of 10 elements max\nvar[]   int vs3 = [];    // \"vs3\" is an unbounded vector\nvar&[]  int vs4 = &vs1;  // \"vs4\" is an alias to \"vs1\"\n\n\n\n\nPools\n\u00b6\n\n\nA \npool\n declaration specifies a dimension and an\nassociated \ntype\n.\nDeclarations for pools can also be \naliases\n.\nOnly in this case they can be \ninitialized\n.\n\n\nThe expression between the brackets specifies the \ndimension\n of\nthe pool.\n\n\nExamples:\n\n\ncode/await Play (...) do ... end\npool[10] Play plays;        // \"plays\" is a static pool of 10 elements max\npool&[]  Play a = &plays;   // \"a\" is an alias to \"plays\"\n\n\n\n\n\n\n\nTODO: data pools\n\n\nDimension\n\u00b6\n\n\nDeclarations for \nvectors\n or \npools\n require an expression\nbetween brackets to specify a dimension as follows:\n\n\n\n\nconstant expression\n: Maximum number of elements is fixed and space is\n                         statically pre-allocated.\n\n\nvariable expression\n: Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.\n\n\nomitted\n: Maximum number of elements is unbounded and space is dynamically\n             allocated.\n             The space for dynamic dimensions grow and shrink automatically.\n\n\nTODO: ring buffers\n\n\n\n\nEvents\n\u00b6\n\n\nAn \nevent\n declaration specifies a\n\ntype\n for the values it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\n\n\n\n\n\nExternal Events\n\u00b6\n\n\nExamples:\n\n\ninput  none A;          // \"A\" is an input event carrying no values\noutput int  MY_EVT;     // \"MY_EVT\" is an output event carrying integer values\ninput (int,byte&&) BUF; // \"BUF\" is an input event carrying an \"(int,byte&&)\" pair\n\n\n\n\nTODO: output &/impl\n\n\nInternal Events\n\u00b6\n\n\nDeclarations for internal events can also be\n\naliases\n.\nOnly in this case they can be \ninitialized\n.\n\n\nExamples:\n\n\nevent  none a;          // \"a\" is an internal events carrying no values\nevent& none z = &a;     // \"z\" is an alias to event \"a\"\nevent (int,int) c;      // \"c\" is a internal event carrying an \"(int,int)\" pair\n\n\n\n\nAssignments\n\u00b6\n\n\nAn assignment associates the statement or expression at the right side of the\nsymbol \n=\n with the \nlocation(s)\n at the left side:\n\n\nAssignment ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n\nSources ::= ( Do\n            | Emit_Ext\n            | Await\n            | Watching\n            | Thread\n            | Lua_Stmts\n            | Code_Await\n            | Code_Spawn\n            | Vec_Cons\n            | Data_Cons\n            | Exp\n            | `_\u00b4 )\n\n\n\n\nC\u00e9u supports the following constructs as assignment sources:\n\n\n\n\ndo-end\n block\n\n\nexternal emit\n\n\nawait\n\n\nwatching statement\n\n\nthread\n\n\nlua statement\n\n\ncode await\n\n\ncode spawn\n\n\nvector \nlength\n & \nconstructor\n\n\ndata constructor\n\n\nexpression\n\n\nthe special identifier \n_\n\n\n\n\nThe special identifier \n_\n makes the assignment innocuous.\nIn the case of assigning to an \noption type\n, the \n_\n unsets\nit.\n\n\nTODO: required for uninitialized variables\n\n\nCopy Assignment\n\u00b6\n\n\nA \ncopy assignment\n evaluates the statement or expression at the right side and\ncopies the result(s) to the location(s) at the left side.\n\n\nAlias Assignment\n\u00b6\n\n\nAn \nalias assignment\n, aka \nbinding\n, makes the location at the left side to be\nan \nalias\n to the expression at the right side.\n\n\nThe right side of a binding must always be prefixed with the operator \n&\n.\n\n\nEvent Handling\n\u00b6\n\n\nAwait\n\u00b6\n\n\nThe \nawait\n statement halts the running trail until the specified event occurs.\nThe event can be an \ninput event\n, an\n\ninternal event\n, a terminating\n\ncode abstraction\n, a timer, a\n\npausing event\n, or forever (i.e., never awakes):\n\n\nAwait ::= await (ID_ext | Loc) [until Exp]      /* events and option aliases */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */\n\n\n\n\nExamples:\n\n\nawait A;                  // awaits the input event \"A\"\nawait a until v==10;      // awaits the internal event \"a\" until the condition is satisfied\n\nvar&? My_Code my = <...>; // acquires a reference to a code abstraction instance\nawait my;                 // awaits it terminate\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable \"t\" in milliseconds\n\nawait FOREVER;            // awaits forever\n\n\n\n\nAn \nawait\n evaluates to zero or more values which can be captured with an\noptional \nassignment\n.\n\n\nEvent\n\u00b6\n\n\nThe \nawait\n statement for events halts the running trail until the specified\n\ninput event\n or\n\ninternal event\n occurs.\nThe \nawait\n evaluates to a value of the type of the event.\n\n\nThe optional clause \nuntil\n tests an awaking condition.\nThe condition can use the returned value from the \nawait\n.\nIt expands to a \nloop\n as follows:\n\n\nloop do\n    <ret> = await <evt>;\n    if <Exp> then   // <Exp> can use <ret>\n        break;\n    end\nend\n\n\n\n\nExamples:\n\n\ninput int E;                    // \"E\" is an input event carrying \"int\" values\nvar int v = await E until v>10; // assigns occurring \"E\" to \"v\", awaking only when \"v>10\"\n\nevent (bool,int) e;             // \"e\" is an internal event carrying \"(bool,int)\" pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on \"e\" and assigns its values to \"v1\" and \"v2\"\n\n\n\n\nCode Abstraction\n\u00b6\n\n\nThe \nawait\n statement for a \ncode abstraction\n halts the running trail\nuntil the specified instance terminates.\n\n\nThe \nawait\n evaluates to the return value of the abstraction.\n\n\nTODO: option return on kill\n\n\nExample:\n\n\nvar&? My_Code my = spawn My_Code();\nvar? int ret = await my;\n\n\n\n\nTimer\n\u00b6\n\n\nThe \nawait\n statement for timers halts the running trail until the specified\ntimer expires:\n\n\n\n\nWCLOCKK\n specifies a constant timer expressed as a sequence of value/unit\n  pairs.\n\n\nWCLOCKE\n specifies an \ninteger\n expression in\n  parenthesis followed by a single unit of time.\n\n\n\n\nThe \nawait\n evaluates to a value of type \ns32\n and is the\n\nresidual delta time (\ndt\n)\n measured in microseconds:\n    the difference between the actual elapsed time and the requested time.\nThe residual \ndt\n is always greater than or equal to 0.\n\n\nIf a program awaits timers in sequence (or in a \nloop\n), the residual \ndt\n from\nthe preceding timer is reduced from the timer in sequence.\n\n\nExamples:\n\n\nvar int t = <...>;\nawait (t)ms;                // awakes after \"t\" milliseconds\n\n\n\n\nvar int dt = await 100us;   // if 1000us elapses, then dt=900us (1000-100)\nawait 100us;                // since dt=900, this timer is also expired, now dt=800us (900-100)\nawait 1ms;                  // this timer only awaits 200us (1000-800)\n\n\n\n\n\n\n\nPausing\n\u00b6\n\n\nPausing events are dicussed in \nPausing\n.\n\n\nFOREVER\n\u00b6\n\n\nThe \nawait\n statement for \nFOREVER\n halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.\n\n\nExample:\n\n\nif v==10 then\n    await FOREVER;  // this trail never awakes if condition is true\nend\n\n\n\n\nEmit\n\u00b6\n\n\nThe \nemit\n statement broadcasts an event to the whole program.\nThe event can be an \nexternal event\n, an\n\ninternal event\n, or a timer:\n\n\nEmit_Int ::= emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\nEmit_Ext ::= emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n          |  emit (WCLOCKK|WCLOCKE)\n\n\n\n\nExamples:\n\n\nemit A;         // emits the output event `A` of type \"none\"\nemit a(1);      // emits the internal event `a` of type \"int\"\n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds\n\n\n\n\nEvents\n\u00b6\n\n\nThe \nemit\n statement for events expects the arguments to match the event type.\n\n\nAn \nemit\n to an input or timer event can only occur inside\n\nasynchronous blocks\n.\n\n\nAn \nemit\n to an output event is also an expression that evaluates to a value of\ntype \ns32\n and can be captured with an optional \nassignment\n (its\nmeaning is platform dependent).\n\n\nAn \nemit\n to an internal event starts a new\n\ninternal reaction\n.\n\n\nExamples:\n\n\ninput int I;\nasync do\n    emit I(10);         // broadcasts \"I\" to the application itself, passing \"10\"\nend\n\noutput none O;\nvar int ret = emit O(); // outputs \"O\" to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts \"e\" passing a pair of \"int\" values\n\n\n\n\nTimer\n\u00b6\n\n\nThe \nemit\n statement for timers expects a \ntimer expression\n.\n\n\nLike input events, time can only be emitted inside \nasynchronous \nblocks\n.\n\n\nExamples:\n\n\nasync do\n    emit 1s;    // broadcasts \"1s\" to the application itself\nend\n\n\n\n\nLock\n\u00b6\n\n\nTODO\n\n\nConditional\n\u00b6\n\n\nThe \nif-then-else\n statement provides conditional execution in C\u00e9u:\n\n\nIf ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end\n\n\n\n\nEach condition \nExp\n is tested in sequence, first for the \nif\n clause and then\nfor each of the optional \nelse/if\n clauses.\nOn the first condition that evaluates to \ntrue\n, the \nBlock\n following it\nexecutes.\nIf all conditions fail, the optional \nelse\n clause executes.\n\n\nAll conditions must evaluate to a value of type \nbool\n.\n\n\n\nLoops\n\u00b6\n\n\nC\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:\n\n\nLoop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] NumericRange do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\nNumericRange ::= /* (see \"Numeric Iterator\") */\n\n\n\n\nThe body of a loop \nBlock\n executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.\n\n\nExcept for the \nevery\n iterator, all loops support an optional constant\nexpression \n`/\u00b4Exp\n that limits the maximum number of\niterations to avoid \ninfinite execution\n.\nIf the number of iterations reaches the limit, a runtime error occurs.\n\n\n\n\n\nbreak\n and \ncontinue\n\u00b6\n\n\nThe \nbreak\n statement aborts the deepest enclosing loop.\n\n\nThe \ncontinue\n statement aborts the body of the deepest enclosing loop and\nrestarts it in the next iteration.\n\n\nThe optional modifier \n`/\u00b4ID_int\n in both statements\nonly applies to \nnumeric iterators\n.\n\n\nSimple Loop\n\u00b6\n\n\nThe simple \nloop-do-end\n statement executes its body forever:\n\n\nSimpleLoop ::= loop [`/\u00b4Exp] do\n                   Block\n               end\n\n\n\n\nThe only way to terminate a simple loop is with the \nbreak\n statement.\n\n\nExamples:\n\n\n// blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend\n\n\n\n\nloop do\n    loop do\n        if <cnd-1> then\n            break;      // aborts the loop at line 2 if <cnd-1> is satisfied\n        end\n    end\n    if <cnd-2> then\n        continue;       // restarts the loop at line 1 if <cnd-2> is satisfied\n    end\nend\n\n\n\n\nNumeric Iterator\n\u00b6\n\n\nThe numeric loop executes its body a fixed number of times based on a numeric\nrange for a control variable:\n\n\nNumericIterator ::= loop [`/\u00b4Exp] NumericRange do\n                        Block\n                    end\n\nNumericRange ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                       ( (     Exp `->\u00b4 (`_\u00b4|Exp))\n                                       | (`_\u00b4|Exp) `<-\u00b4 Exp      ) )\n                                   (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]\n\n\n\n\nThe control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:\n\n\n\n\ncontrol variable:\n\n    \nID_int\n is a read-only variable of a \nnumeric type\n.\n    Alternatively, the special anonymous identifier \n_\n can be used if the body\n    of the loop does not access the variable.\n\n\n\n\ninterval:\n\n    Specifies a direction, endpoints with open or closed modifiers, and a step.\n\n\n\n\ndirection\n:\n\n\n->\n: Starts from the endpoint \nExp\n on the left increasing towards \nExp\n on the right.\n\n\n<-\n: Starts from the endpoint \nExp\n on the right decreasing towards \nExp\n on the left.\nTypically, the value on the left is smaller or equal to the value on\nthe right.\n\n\n\n\n\n\nendpoints\n:\n    \n[Exp\n and \nExp]\n are closed intervals which include \nExp\n as the\n    endpoints;\n    \n]Exp\n and \nExp[\n are open intervals which exclude \nExp\n as the\n    endpoints.\n    Alternatively, the finishing endpoint may be \n_\n which means that the\n    interval goes towards infinite.\n\n\nstep\n:\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value \n1\n.\n    If the direction is \n->\n, the step is added, otherwise it is subtracted.\n\n\n\n\nIf the interval is not specified, it assumes the default \n[0 -> _[\n.\n\n\n\n\n\n\nA numeric iterator executes as follows:\n\n\n\n\n\n\ninitialization:\n\n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step\n    immediately.\n\n\n\n\n\n\niteration:\n\n\n\n\nlimit check:\n\n    If the control variable crossed the finishing endpoint, the loop\n    terminates.\n\n\nbody execution:\n\n    The loop body executes.\n\n\nstep\n\n    Applies a step to the control variable. Goto step \n1\n.\n\n\n\n\n\n\n\n\nThe \nbreak\n and \ncontinue\n statements inside numeric iterators accept an\noptional modifier \n`/\u00b4ID_int\n to affect the enclosing\nloop matching the control variable.\n\n\nExamples:\n\n\n// prints \"i=0\", \"i=1\", ...\nvar int i;\nloop i do\n    _printf(\"i=%d\\n\", i);\nend\n\n\n\n\n// awaits 1s and prints \"Hello World!\" 10 times\nloop _ in [0 -> 10[ do\n    await 1s;\n    _printf(\"Hello World!\\n\");\nend\n\n\n\n\nvar int i;\nloop i do\n    var int j;\n    loop j do\n        if <cnd-1> then\n            continue/i;         // continues the loop at line 1\n        else/if <cnd-2> then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend\n\n\n\n\nNote : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.\n\n\nEvent Iterator\n\u00b6\n\n\nThe \nevery\n statement iterates over an event continuously, executing its\nbody whenever the event occurs:\n\n\nEventIterator ::= every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n                      Block\n                  end\n\n\n\n\nThe event can be an \nexternal or internal event\n or a \ntimer\n.\n\n\nThe optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.\n\n\nAn \nevery\n expands to a \nloop\n as illustrated below:\n\n\nevery <vars> in <event> do\n    <body>\nend\n\n\n\n\nis equivalent to\n\n\nloop do\n    <vars> = await <event>;\n    <body>\nend\n\n\n\n\nHowever, the body of an \nevery\n cannot contain\n\nsynchronous control statements\n, ensuring\nthat no occurrences of the specified event are ever missed.\n\n\nTODO: reject break inside every\n\n\nExamples:\n\n\nevery 1s do\n    _printf(\"Hello World!\\n\");      // prints the \"Hello World!\" message on every second\nend\n\n\n\n\nevent (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received \"cnd\" is false\n    else\n        _printf(\"v = %d\\n\", v);     // prints the received \"v\" otherwise\n    end\nend\n\n\n\n\nPool Iterator\n\u00b6\n\n\nThe \npool\n iterator visits all alive\n\nabstraction\n instances residing in a given pool:\n\n\nPoolIterator ::= loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n                     Block\n                 end\n\n\n\n\nOn each iteration, the optional control variable becomes a\n\nreference\n to an instance, starting from the oldest created\nto the newest.\n\n\nThe control variable must be an alias to the same type of the pool with the\nsame rules that apply to \nspawn\n.\n\n\nExamples:\n\n\npool[] My_Code my_codes;\n\n<...>\n\nvar&? My_Code my_code;\nloop my_code in mycodes do\n    <...>\nend\n\n\n\n\nParallel Compositions\n\u00b6\n\n\nPars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nSpawn ::= spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n              Block\n          end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Abs_Cons) do\n                 Block\n             end\n\n\n\n\nThe parallel statements \npar/and\n, \npar/or\n, and \npar\n fork the running trail \nin multiple others.\nThey differ only on how trails rejoin and terminate the composition.\n\n\nThe \nspawn\n statement starts to execute a block in parallel with the enclosing\nblock.\n\n\nThe \nwatching\n statement executes a block and terminates when one of its\nspecified events occur.\n\n\nSee also \nParallel Compositions and Abortion\n.\n\n\npar\n\u00b6\n\n\nThe \npar\n statement never rejoins.\n\n\nExamples:\n\n\n// reacts continuously to \"1s\" and \"KEY_PRESSED\" and never terminates\ninput none KEY_PRESSED;\npar do\n    every 1s do\n        <...>           // does something every \"1s\"\n    end\nwith\n    every KEY_PRESSED do\n        <...>           // does something every \"KEY_PRESSED\"\n    end\nend\n\n\n\n\npar/and\n\u00b6\n\n\nThe \npar/and\n statement stands for \nparallel-and\n and rejoins when all nested\ntrails terminate.\n\n\nExamples:\n\n\n// reacts once to \"1s\" and \"KEY_PRESSED\" and terminates\ninput none KEY_PRESSED;\npar/and do\n    await 1s;\n    <...>               // does something after \"1s\"\nwith\n    await KEY_PRESSED;\n    <...>               // does something after \"KEY_PRESSED\"\nend\n\n\n\n\npar/or\n\u00b6\n\n\nThe \npar/or\n statement stands for \nparallel-or\n and rejoins when any of the \ntrails terminate, aborting all other trails.\n\n\nExamples:\n\n\n// reacts once to `1s` or `KEY_PRESSED` and terminates\ninput none KEY_PRESSED;\npar/or do\n    await 1s;\n    <...>               // does something after \"1s\"\nwith\n    await KEY_PRESSED;\n    <...>               // does something after \"KEY_PRESSED\"\nend\n\n\n\n\nspawn\n\u00b6\n\n\nThe \nspawn\n statement starts to execute a block in parallel with the enclosing\nblock.\nWhen the enclosing block terminates, the spawned block is aborted.\n\n\nLike a \ndo-end\n block\n, a \nspawn\n also supports an\noptional list of identifiers in parenthesis which restricts the visible\nvariables inside the block to those matching the list.\n\n\nExamples:\n\n\nspawn do\n    every 1s do\n        <...>       // does something every \"1s\"...\n    end\nend\n\n<...>               // ...in parallel with whatever comes next\n\n\n\n\nwatching\n\u00b6\n\n\nA \nwatching\n expands to a \npar/or\n with \nn+1\n trails:\none to await each of the listed events,\nand one to execute its body, i.e.:\n\n\nwatching <e1>,<e2>,... do\n    <body>\nend\n\n\n\n\nexpands to\n\n\npar/or do\n    await <e1>;\nwith\n    await <e2>;\nwith\n    ...\nwith\n    <body>\nend\n\n\n\n\nThe \nwatching\n statement accepts a list of events and terminates when any of\nthem occur.\nThe events are the same supported by the \nawait\n statement.\nIt evaluates to what the occurring event value(s), which can be captured with\nan optional \nassignment\n.\n\n\nIf the event is a \ncode abstraction\n, the nested blocked does not\nrequire the unwrap operator \n!\n.\n\n\nExamples:\n\n\n// reacts continuously to \"KEY_PRESSED\" during \"1s\"\ninput none KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n        <...>           // does something every \"KEY_PRESSED\"\n    end\nend\n\n\n\n\nPausing\n\u00b6\n\n\nThe \npause/if\n statement controls if its body should temporarily stop to react\nto events:\n\n\nPause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)\n\n\n\n\nA \npause/if\n specifies a pausing event of type \nbool\n which, when emitted,\ntoggles between pausing (\ntrue\n) and resuming (\nfalse\n) reactions for its body.\n\n\nWhen its body terminates, the whole \npause/if\n terminates and proceeds to the\nstatement in sequence.\n\n\nIn transition instants, the body can react to the special \npause\n and \nresume\n\nevents before the corresponding state applies.\n\n\nTODO: finalize/pause/resume\n\n\nExamples:\n\n\nevent bool e;\npause/if e do       // pauses/resumes the nested body on each \"e\"\n    every 1s do\n        <...>       // does something every \"1s\"\n    end\nend\n\n\n\n\nevent bool e;\npause/if e do               // pauses/resumes the nested body on each \"e\"\n    <...>\n        loop do\n            await pause;\n            <...>           // does something before pausing\n            await resume;\n            <...>           // does something before resuming\n        end\n    <...>\nend\n\n\n\n\n\n\n\nExceptions\n\u00b6\n\n\nTODO\n\n\nThrow ::= throw Exp\nCatch ::= catch LIST(Loc) do\n              Block\n          end\n\n\n\n\nAsynchronous Execution\n\u00b6\n\n\nAsynchronous execution allow programs to departure from the rigorous\nsynchronous model and preform computations under separate scheduling rules.\n\n\nC\u00e9u supports \nasynchronous blocks\n, \nthreads\n, and\n\ninterrupt service routines\n:\n\n\nAsync  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nIsr ::= spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\nAtomic ::= atomic do\n               Block\n           end\n\n\n\n\nAsynchronous execution supports \ntight loops\n while\nkeeping the rest of the application, aka the \nsynchronous side\n, reactive to\nincoming events.  However, it does not support any\n\nsynchronous control statement\n (e.g.,\nparallel compositions, event handling, pausing, etc.).\n\n\nBy default, asynchronous bodies do not share variables with their enclosing\nscope, but the optional list of variables makes them visible to the block.\n\n\nEven though asynchronous blocks execute in separate, they are still managed by\nthe program hierarchy and are also subject to lexical scope and abortion.\n\n\n\n\n\nAsynchronous Block\n\u00b6\n\n\nAsynchronous blocks, aka \nasyncs\n, intercalate execution with the synchronous\nside as follows:\n\n\n\n\nStart/Resume whenever the synchronous side is idle.\n   When multiple \nasyncs\n are active, they execute in lexical order.\n\n\nSuspend after each \nloop\n iteration.\n\n\nSuspend on every input \nemit\n (see \nSimulation\n).\n\n\nExecute atomically and to completion unless rules \n2\n and \n3\n apply.\n\n\n\n\nThis rules imply that \nasyncs\n never execute with real parallelism with the\nsynchronous side, preserving determinism in the program.\n\n\nExamples:\n\n\n// calculates the factorial of some \"v\" if it doesn't take too long\nvar u64  v   = <...>;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps \"v\" and \"fat\" visible\n        loop i in [1 -> v] do   // reads from \"v\"\n            fat = fat * i;      // writes to \"fat\"\n        end\n    end\n    ok = true;                  // completed within \"1s\"\nend\n\n\n\n\nSimulation\n\u00b6\n\n\nAn \nasync\n block can emit \ninput and timer events\n towards the\nsynchronous side, providing a way to test programs in the language itself.\nEvery time an \nasync\n emits an event, it suspends until the synchronous side\nreacts to the event (see \nrule 1\n above).\n\n\nExamples:\n\n\ninput int A;\n\n// tests a program with input simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -> _[ do\n        await 10ms;\n        _printf(\"v = %d\\n\", v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for \"v\"\n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v = <v+i>` exactly 103 times.\n\n\n\n\nThread\n\u00b6\n\n\nThreads provide real parallelism for applications in C\u00e9u.\nOnce started, a thread executes completely detached from the synchronous side.\nFor this reason, thread execution is non deterministic and require explicit\n\natomic blocks\n on accesses to variables to avoid race\nconditions.\n\n\nA thread evaluates to a boolean value which indicates whether it started\nsuccessfully or not.\nThe value can be captured with an optional \nassignment\n.\n\n\nExamples:\n\n\n// calculates the factorial of some \"v\" if it doesn't take too long\nvar u64  v   = <...>;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps \"v\" and \"fat\" visible\n        loop i in [1 -> v] do       // reads from \"v\"\n            fat = fat * i;          // writes to \"fat\"\n        end\n    end\n    ok = true;                      // completed within \"1s\"\nend\n\n\n\n\nAsynchronous Interrupt Service Routine\n\u00b6\n\n\nTODO\n\n\nAtomic Block\n\u00b6\n\n\nAtomic blocks provide mutual exclusion among threads, interrupts, and the\nsynchronous side of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.\n\n\nExamples:\n\n\n// A \"race\" between two threads: one incrementing, the other decrementing \"count\".\n\nvar s64 count = 0;                              // \"count\" is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf(\"count = %d\\n\", count);     // prints current value of \"count\" every \"1s\"\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements \"count\" as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments \"count\" as fast as possible\n            end\n        end\n    end\nend\n\n\n\n\nC Integration\n\u00b6\n\n\n\n\n\nC\u00e9u provides \nnative declarations\n to import C symbols,\n\nnative blocks\n to define new code in C,\n\nnative statements\n to inline C statements,\n\nnative calls\n to call C functions,\nand \nfinalization\n to deal with C pointers safely:\n\n\nNat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 LIST(ID_nat) `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                   <code definitions in C>\n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 {<code in C> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nFinalization ::= do [Stmt] Finalize\n              |  var [`&\u00b4|`&?\u00b4] Type ID_int `=\u00b4 `&\u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize [ `(\u00b4 LIST(Loc) `)\u00b4 ] with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end\n\n\n\n\nNative calls and statements transfer execution to C, losing the guarantees of\nthe \nsynchronous model\n.\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple \nstruct\n accessors, but\nnever for control purposes.\n\n\nTODO: Nat_End\n\n\nNative Declaration\n\u00b6\n\n\nIn C\u00e9u, any \nidentifier\n prefixed with an\nunderscore is a native symbol defined externally in C.\nHowever, all external symbols must be declared before their first use in a\nprogram.\n\n\nNative declarations support four modifiers as follows:\n\n\n\n\nconst\n: declares the listed symbols as constants.\n    Constants can be used as bounded limits in \nvectors\n,\n    \npools\n, and \nnumeric loops\n.\n    Also, constants cannot be \nassigned\n.\n\n\nplain\n: declares the listed symbols as \nplain\n types, i.e., types (or\n    composite types) that do not contain pointers.\n    A value of a plain type passed as argument to a function does not require\n    \nfinalization\n.\n\n\nnohold\n: declares the listed symbols as \nnon-holding\n functions, i.e.,\n    functions that do not retain received pointers after returning.\n    Pointers passed to non-holding functions do not require\n    \nfinalization\n.\n\n\npure\n: declares the listed symbols as pure functions.\n    In addition to the \nnohold\n properties, pure functions never allocate\n    resources that require \nfinalization\n\n    and have no side effects to take into account for the \nsafety checks\n.\n\n\n\n\nExamples:\n\n\n// values\nnative/const  _LOW, _HIGH;      // Arduino \"LOW\" and \"HIGH\" are constants\nnative        _errno;           // POSIX \"errno\" is a global variable\n\n// types\nnative/plain  _char;            // \"char\" is a \"plain\" type\nnative        _SDL_PixelFormat; // SDL \"SDL_PixelFormat\" is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv \"uv_read_start\" retains the received pointer\nnative/nohold _free;            // POSIX \"free\" receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX \"strlen\" is a \"pure\" function\n\n\n\n\nNative Block\n\u00b6\n\n\nA native block allows programs to define new external symbols in C.\n\n\nThe contents of native blocks is copied unchanged to the output in C depending\non the modifier specified:\n\n\n\n\npre\n: code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in \npre\n blocks are visible to C\u00e9u.\n\n\npos\n: code is placed after the declarations for the C\u00e9u program.\n    Symbols implicitly defined by the compiler of C\u00e9u are visible to \npos\n\n    blocks.\n\n\n\n\nNative blocks are copied in the order they appear in the source code.\n\n\nSince C\u00e9u uses the \nC preprocessor\n, hash\ndirectives \n#\n inside native blocks must be quoted as \n##\n to be considered\nonly in the C compilation phase.\n\n\nIf the code in C contains the terminating \nend\n keyword of C\u00e9u, the \nnative\n\nblock should be delimited with matching comments to avoid confusing the parser:\n\n\nSymbols defined in native blocks still need to be\n\ndeclared\n for use in the program.\n\n\nExamples:\n\n\nnative/plain _t;\nnative/pre do\n    typedef int t;              // definition for \"t\" is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires \"t\" to be already defined\n\n\n\n\ninput none A;                   // declaration for \"A\" is placed before \"pos\" blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires \"A\" to be already declared\n    }\nend\n\n\n\n\nnative/nohold _printf;\nnative/pre do\n    ##include <stdio.h>         // include the relevant header for \"printf\"\nend\n\n\n\n\nnative/pos do\n    /******/\n    char str = \"This `end` confuses the parser\";\n    /******/\nend\n\n\n\n\nNative Statement\n\u00b6\n\n\nThe contents of native statements in between \n{\n and \n}\n are inlined in the\nprogram.\n\n\nNative statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by the symbol \n@\n.\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf(\"%d\\n\", @v_ceu);     // prints 30\n}\n\n\n\n\nNative Call\n\u00b6\n\n\nExpressions that evaluate to a \nnative type\n can be called\nfrom C\u00e9u.\n\n\nIf a call passes or returns pointers, it may require an accompanying\n\nfinalization statement\n.\n\n\nExamples:\n\n\n// all expressions below evaluate to a native type and can be called\n\n_printf(\"Hello World!\\n\");\n\nvar _t f = <...>;\nf();\n\nvar _s s = <...>;\ns.f();\n\n\n\n\n\n\n\nResources & Finalization\n\u00b6\n\n\nA finalization statement unconditionally executes a series of statements when\nits associated block terminates or is aborted.\n\n\nC\u00e9u tracks the interaction of native calls with pointers and requires \n\nfinalize\n clauses to accompany the calls:\n\n\n\n\nIf C\u00e9u \npasses\n a pointer to a native call, the pointer represents a\n  \nlocal resource\n that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.\n\n\nIf C\u00e9u \nreceives\n a pointer from a native call return, the pointer\n  represents an \nexternal resource\n that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.\n\n\n\n\nIn both cases, the program does not compile without the \nfinalize\n statement.\n\n\nA \nfinalize\n cannot contain\n\nsynchronous control statements\n.\n\n\nExamples:\n\n\n// Local resource finalization\nwatching <...> do\n    var _buffer_t msg;\n    <...>                       // prepares msg\n    do\n        _send_request(&&msg);\n    finalize with\n        _send_cancel(&&msg);\n    end\n    await SEND_ACK;             // transmission is complete\nend\n\n\n\n\nIn the example above, the local variable \nmsg\n is an internal resource passed\nas a pointer to \n_send_request\n, which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait SEND_ACK\n,\nthe local \nmsg\n goes out of scope and the external transmission would hold a\n\ndangling pointer\n.\nThe \nfinalize\n ensures that \n_send_cancel\n also aborts the transmission.\n\n\n// External resource finalization\nwatching <...> do\n    var&? _FILE f = &_fopen(<...>) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite(<...>, f);\n    await A;\n    _fwrite(<...>, f);\nend\n\n\n\n\nIn the example above, the call to \n_fopen\n returns an external file resource as\na pointer.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait A\n, the file\nwould remain open as a \nmemory leak\n.\nThe \nfinalize\n ensures that \n_fclose\n closes the file properly.\n\n\nTo access an external resource from C\u00e9u requires an\n\nalias assignment\n to a\n\nvariable alias\n.\nIf the external call returns \nNULL\n and the variable is an option alias\n\nvar&?\n, the alias remains unbounded.\nIf the variable is an alias \nvar&\n, the assigment raises a runtime error.\n\n\nNote: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.\n\n\nDeclaration\n and \nexpression\n\nmodifiers may suppress the requirement for finalization in calls:\n\n\n\n\nnohold\n modifiers or \n/nohold\n typecasts make passing pointers safe.\n\n\npure\n   modifiers or \n/pure\n   typecasts make passing pointers and returning\n                                  pointers safe.\n\n\n/plain\n typecasts make return values safe.\n\n\n\n\nExamples:\n\n\n// \"_free\" does not retain \"ptr\"\nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);\n\n\n\n\n// \"_strchr\" does retain \"ptr\" or allocates resources\nnative/pure _strchr;\nvar _char&& found = _strchr(ptr);\n// or\nvar _char&& found = (_strchr as /pure)(ptr);\n\n\n\n\n// \"_f\" returns a non-pointer type\nvar _tp v = _f() as /plain;\n\n\n\n\nLua Integration\n\u00b6\n\n\nC\u00e9u provides \nLua states\n to delimit the effects of inlined\n\nLua statements\n.\nLua statements transfer execution to the Lua runtime, losing the guarantees of\nthe \nsynchronous model\n:\n\n\nLua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { {<code in Lua> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n              `]\u00b4 {`=\u00b4} `]\u00b4\n\n\n\n\nPrograms have an implicit enclosing \nglobal Lua state\n which all orphan\nstatements apply.\n\n\nLua State\n\u00b6\n\n\nA Lua state creates an isolated state for inlined\n\nLua statements\n.\n\n\nExample:\n\n\n// \"v\" is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend\n\n\n\n\nTODO: dynamic scope, assignment/error, [dim]\n\n\nLua Statement\n\u00b6\n\n\nThe contents of Lua statements in between \n[[\n and \n]]\n are inlined in the\nprogram.\n\n\nLike \nnative statements\n, Lua statements support\ninterpolation of expressions in C\u00e9u which are expanded when preceded by a \n@\n.\n\n\nLua statements only affect the \nLua state\n in which they are embedded.\n\n\nIf a Lua statement is used in an \nassignment\n, it is evaluated as\nan expression that either satisfies the destination or generates a runtime\nerror.\nThe list that follows specifies the \nC\u00e9u destination\n and expected\n\nLua source\n:\n\n\n\n\na \nboolean\n \nvariable\n\n    expects a \nboolean\n value\n\n\na \nnumeric\n \nvariable\n\n    expects a \nnumber\n value\n\n\na \npointer\n \nvariable\n\n    expects a \nlightuserdata\n value\n\n\na \nbyte\n \nvector\n\n    expects a \nstring\n value\n\n\n\n\nTODO: lua state captures errors\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]\n\n\n\n\nAbstractions\n\u00b6\n\n\nC\u00e9u supports reuse with \ndata\n declarations to define new types, and \ncode\n\ndeclarations to define new subprograms.\n\n\nDeclarations are subject to \nlexical scope\n.\n\n\nData\n\u00b6\n\n\nA \ndata\n declaration creates a new data type:\n\n\nData ::= data ID_abs [as (nothing|Exp)] [ with\n             (Var|Vec|Pool|Int) `;\u00b4 { (Var|Vec|Pool|Int) `;\u00b4 }\n         end\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n\n\n\n\nA declaration may pack fields with\n\nstorage declarations\n which become publicly\naccessible in the new type.\nField declarations may \nassign\n default values for\nuninitialized instances.\n\n\nData types can form hierarchies using dots (\n.\n) in identifiers:\n\n\n\n\nAn isolated identifier such as \nA\n makes \nA\n a base type.\n\n\nA dotted identifier such as \nA.B\n makes \nA.B\n a subtype of its supertype \nA\n.\n\n\n\n\nA subtype inherits all fields from its supertype.\n\n\nThe optional modifier \nas\n expects the keyword \nnothing\n or a constant\nexpression of type \nint\n:\n\n\n\n\nnothing\n: the \ndata\n cannot be instantiated.\n\n\nconstant expression\n: \ntypecasting\n a value of\n                         the type to \nint\n evaluates to the specified\n                         enumeration expression.\n\n\n\n\nExamples:\n\n\ndata Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  // \"r.z\" defaults to 0\n\n\n\n\ndata Dir       as nothing;  // \"Dir\" is a base type and cannot be intantiated\ndata Dir.Right as  1;       // \"Dir.Right\" is a subtype of \"Dir\"\ndata Dir.Left  as -1;       // \"Dir.Left\"  is a subtype of \"Dir\"\nvar  Dir dir = <...>;       // receives one of \"Dir.Right\" or \"Dir.Left\"\nescape (dir as int);        // returns 1 or -1\n\n\n\n\nTODO: new, pool, recursive types\n\n\nData Constructor\n\u00b6\n\n\nA new data value is created in the contexts that follow:\n\n\n\n\nPrefixed by the keyword \nval\n in an \nassignment\n to a variable.\n\n\nAs an argument to a \ncode\n invocation\n.\n\n\nNested as an argument in a \ndata\n creation (i.e., a \ndata\n that contains\n  another \ndata\n).\n\n\n\n\nIn all cases, the arguments are copied to the destination.\nThe destination must be a plain declaration (i.e., not an alias or pointer).\n\n\nThe constructor uses the \ndata\n identifier followed by a list of arguments\nmatching the fields of the type.\n\n\nVariables of the exact same type can be copied in \nassignments\n.\n\n\nFor assignments from a subtype to a supertype, the rules are as follows:\n\n\n\n\nCopy assignments\n\n\nplain values: only if the subtype contains no extra fields\n\n\npointers: allowed\n\n\n\n\n\n\nAlias assignment\n: allowed.\n\n\n\n\ndata Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());\n\n\n\n\nvar Object o2 = o1;         // makes a deep copy of all fields from \"o1\" to \"o2\"\n\n\n\n\nCode\n\u00b6\n\n\nThe \ncode/tight\n and \ncode/await\n declarations specify new subprograms that can\nbe invoked from arbitrary points in programs:\n\n\n// prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `->\u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4\n                                        [ `->\u00b4 `(\u00b4 Params `)\u00b4 ]\n                                            `->\u00b4 (Type | NEVER)\n                    [ throws LIST(ID_abs) ]\nParams ::= none | LIST(Var|Vec|Pool|Int)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Abs_Cons\nCode_Spawn ::= spawn Mods Abs_Cons [in Loc]\nCode_Kill  ::= kill Loc [ `(` Exp `)` ]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n\n\n\n\nA \ncode/tight\n is a subprogram that cannot contain\n\nsynchronous control statements\n and its body\nruns to completion in the current \ninternal reaction\n.\n\n\nA \ncode/await\n is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its body execution may outlive\nmultiple reactions.\n\n\nA \nprototype declaration\n specifies the interface parameters of the\nabstraction which invocations must satisfy.\nA \nfull declaration\n (aka \ndefinition\n) also specifies an implementation\nwith a block of code.\nAn \ninvocation\n specifies the name of the code abstraction and arguments\nmatching its declaration.\n\n\nDeclarations can be nested.\nA nested declaration is not visible outside its enclosing declaration.\nThe body of a nested declaration may access entities from its enclosing\ndeclarations with the prefix \nouter\n.\n\n\nTo support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier \n/recursive\n.\n\n\nExamples:\n\n\ncode/tight Absolute (var int v) -> int do   // declares the prototype for \"Absolute\"\n    if v > 0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes \"Absolute\" (yields 10)\n\n\n\n\ncode/await Hello_World (none) -> NEVER do\n    every 1s do\n        _printf(\"Hello World!\\n\");  // prints \"Hello World!\" every second\n    end\nend\nawait Hello_World();                // never awakes\n\n\n\n\ncode/tight/recursive Fat (var int v) -> int;    // \"Fat\" is a recursive code\ncode/tight/recursive Fat (var int v) -> int do\n    if v > 1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes \"Fat\" (yields 3628800)\n\n\n\n\nTODO: hold\n\n\nCode Declaration\n\u00b6\n\n\nCode abstractions specify a list of input parameters in between the symbols\n\n(\n and \n)\n.\nEach parameter specifies an \nentity class\n\nwith modifiers, a type and an identifier.\nA \nnone\n list specifies that the abstraction has no parameters.\n\n\nCode abstractions also specify an output return type.\nA \ncode/await\n may use \nNEVER\n as output to indicate that it never returns.\n\n\nA \ncode/await\n may also specify an optional \npublic field list\n, which are\nlocal storage entities living in the outermost scope of the abstraction body.\nThese entities are visible to the invoking context, which may\n\naccess\n them while the abstraction executes.\nLikewise, nested code declarations in the outermost scope, known as methods,\nare also visible to the invoking context.\n\n\nTODO: throws\n\n\n\n\n\nCode Invocation\n\u00b6\n\n\nA \ncode/tight\n is invoked with the keyword \ncall\n followed by the abstraction\nname and list of arguments.\nA \ncode/await\n is invoked with the keywords \nawait\n or \nspawn\n followed by the\nabstraction name and list of arguments.\n\n\nThe list of arguments must satisfy the list of parameters in the\n\ncode declaration\n.\n\n\nThe \ncall\n and \nawait\n invocations suspend the current trail and transfer\ncontrol to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of its return type which can be captured with an optional\n\nassignment\n.\n\n\nThe \nspawn\n invocation also suspends and transfers control to the code\nabstraction.\nHowever, as soon as the abstraction becomes idle (or terminates), the invoking\npoint resumes.\nThis makes the invocation point and abstraction to execute concurrently.\n\n\nThe \nspawn\n invocation evaluates to a \nreference\n\nrepresenting the instance and can be captured with an optional\n\nassignment\n.\nThe alias must be an \noption alias variable\n of\nthe same type of the code abstraction.\nIf the abstraction never terminates (i.e., return type is \nNEVER\n), the\nvariable may be a simple alias.\nIf the \nspawn\n fails (e.g., lack of memory) the option alias variable is unset.\nIn the case of a simple alias, the assignment raises a runtime error.\n\n\nThe \nspawn\n invocation also accepts an optional \npool\n which provides\nstorage and scope for invoked abstractions.\nWhen the pool goes out of scope, all invoked abstractions residing in that pool\nare aborted.\nIf the \nspawn\n omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is also aborted.\n\n\nTODO: kill\n\n\nCode References\n\u00b6\n\n\nThe \nspawn\n \ninvocation\n and the control variable of\n\npool iterators\n evaluate to a reference as an\n\noption alias\n to an abstraction instance.\nIf the instance terminates at any time, the option variable is automatically\nunset.\n\n\nA reference provides \naccess\n to the public fields and\nmethods of the instance.\n\n\nExamples:\n\n\ncode/await My_Code (var int x) -> (var int y) -> NEVER do\n    y = x;                              // \"y\" is a public field\n\n    code/tight Get_X (none) -> int do   // \"Get_X\" is a public method\n        escape outer.x;\n    end\n\n    await FOREVER;\nend\n\nvar& My_Code c = spawn My_Code(10);\n_printf(\"y=%d, x=%d\\n\", c.y, c.Get_X());    // prints \"y=10, x=10\"\n\n\n\n\nDynamic Dispatching\n\u00b6\n\n\nC\u00e9u supports dynamic code dispatching based on multiple parameters.\n\n\nThe modifier \n/dynamic\n in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one \ndynamic\n parameter.\nAlso, all dynamic parameters must be pointers or aliases to a\n\ndata type\n in some hierarchy.\n\n\nA dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the \ndynamic\n parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.\n\n\nTo determine which declaration to execute during runtime, the actual argument\nruntime type is checked against the first formal \ndynamic\n parameter of each\ndeclaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.\n\n\nA \ncatchall\n declaration with the most general dynamic types must always be\nprovided.\n\n\nIf the argument is explicitly \ntypecast\n to a\nsupertype, then dispatching considers that type instead.\n\n\nExample:\n\n\ndata Media as nothing;\ndata Media.Audio     with <...> end\ndata Media.Video     with <...> end\ndata Media.Video.Avi with <...> end\n\ncode/await/dynamic Play (dynamic var& Media media) -> none do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var& Media.Audio media) -> none do\n    <...>                   // plays an audio\nend\ncode/await/dynamic Play (dynamic var& Media.Video media) -> none do\n    <...>                   // plays a video\nend\ncode/await/dynamic Play (dynamic var& Media.Video.Avi media) -> none do\n    <...>                                   // prepare the avi video\n    await/dynamic Play(&m as Media.Video);  // dispatches the supertype\nend\n\nvar& Media m = <...>;       // receives one of \"Media.Audio\" or \"Media.Video\"\nawait/dynamic Play(&m);     // dispatches the appropriate subprogram to play the media\n\n\n\n\nSynchronous Control Statements\n\u00b6\n\n\nThe \nsynchronous control statements\n which follow cannot appear in\n\nevent iterators\n,\n\npool iterators\n,\n\nasynchronous execution\n,\n\nfinalization\n,\nand\n\ntight code abstractions\n:\n\nawait\n, \nspawn\n, \nemit\n (internal events), \nevery\n, \nfinalize\n, \npause/if\n,\n\npar\n, \npar/and\n, \npar/or\n, and \nwatching\n.\n\n\nAs exceptions, an \nevery\n can \nemit\n internal events, and a \ncode/tight\n can\ncontain empty \nfinalize\n statements.",
            "title": "Statements"
        },
        {
            "location": "/statements/#statements",
            "text": "A program in C\u00e9u is a sequence of statements delimited by an implicit enclosing\nblock:  Program ::= Block\nBlock   ::= {Stmt `;\u00b4}  Note: statements terminated with the  end  keyword do not require a\nterminating semicolon.",
            "title": "Statements"
        },
        {
            "location": "/statements/#nothing",
            "text": "nothing  is an innocuous statement:  Nothing ::= nothing",
            "title": "Nothing"
        },
        {
            "location": "/statements/#blocks",
            "text": "A  Block  delimits a lexical scope for storage entities \nand abstractions ,\nwhich are only visible to statements inside the block.  Compound statements (e.g.  do-end ,  if-then-else ,  loops , etc.) create new\nblocks and can be nested to an arbitrary level.",
            "title": "Blocks"
        },
        {
            "location": "/statements/#do-end-and-escape",
            "text": "The  do-end  statement creates an explicit block.\nThe  escape  statement terminates the deepest matching enclosing  do-end :  Do ::= do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]  A  do-end  and  escape  accept an optional identifier following the symbol  / .\nAn  escape  only matches a  do-end  with the same identifier.\nThe neutral identifier  _  in a  do-end  is guaranteed not to match any escape  statement.  A  do-end  also supports an optional list of identifiers in parenthesis which\nrestricts the visible storage entities inside the block to those matching the\nlist.\nAn empty list hides all storage entities from the enclosing scope.  A  do-end  can be  assigned  to a variable whose type must be\nmatched by nested  escape  statements.\nThe whole block evaluates to the value of a reached  escape .\nIf the variable is of  option type , the  do-end  is allowed\nto terminate without an  escape , otherwise it raises a runtime error.  Programs have an implicit enclosing  do-end  that assigns to a program status variable  of type  int  whose meaning is platform dependent.  Examples:  do\n    do/a\n        do/_\n            escape;     // matches line 1\n        end\n        escape/a;       // matches line 2\n    end\nend  var int a;\nvar int b;\ndo (a)\n    a = 1;\n    b = 2;  // \"b\" is not visible\nend  var int? v =\n    do\n        if <cnd> then\n            escape 10;  // assigns 10 to \"v\"\n        else\n            nothing;    // \"v\" remains unassigned\n        end\n    end;  escape 0;               // program terminates with a status value of 0",
            "title": "do-end and escape"
        },
        {
            "location": "/statements/#pre-do-end",
            "text": "The  pre-do-end  statement prepends its statements in the beginning of the\nprogram:  Pre_Do ::= pre do\n               Block\n           end  All  pre-do-end  statements are concatenated together in the order they appear\nand are moved to the beginning of the top-level block, before all other\nstatements.",
            "title": "pre-do-end"
        },
        {
            "location": "/statements/#declarations",
            "text": "A declaration introduces a  storage entity \nto the enclosing block.\nAll declarations are subject to  lexical scope .  C\u00e9u supports variables, vectors, pools, internal events, and external events:  \nVar  ::= var [`&\u00b4|`&?\u00b4] [ `[\u00b4 [Exp [`*`]] `]\u00b4 ] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\nPool ::= pool [`&\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nInt  ::= event [`&\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      |  output (Type | `(\u00b4 LIST([`&\u00b4] Type [ID_int]) `)\u00b4) ID_ext\n            [ do Block end ]\n\nSources ::= /* (see \"Assignments\") */  Most declarations support an initialization  assignment .",
            "title": "Declarations"
        },
        {
            "location": "/statements/#variables",
            "text": "A  variable  declaration has an associated type  and can be optionally  initialized .\nDeclarations can also be aliases or option aliases .  Examples:  var  int v = 10;    // \"v\" is an integer variable initialized to 10\nvar  int a=0, b=3;  // \"a\" and \"b\" are integer variables initialized to 0 and 3\nvar& int z = &v;    // \"z\" is an alias to \"v\"",
            "title": "Variables"
        },
        {
            "location": "/statements/#vectors",
            "text": "A  vector  declaration specifies a dimension  between brackets,\nan associated  type  and can be optionally initialized .\nDeclarations can also be  aliases . TODO: ring buffers   Examples:  var int n = 10;\nvar[10] int vs1 = [];    // \"vs1\" is a static vector of 10 elements max\nvar[n]  int vs2 = [];    // \"vs2\" is a dynamic vector of 10 elements max\nvar[]   int vs3 = [];    // \"vs3\" is an unbounded vector\nvar&[]  int vs4 = &vs1;  // \"vs4\" is an alias to \"vs1\"",
            "title": "Vectors"
        },
        {
            "location": "/statements/#pools",
            "text": "A  pool  declaration specifies a dimension and an\nassociated  type .\nDeclarations for pools can also be  aliases .\nOnly in this case they can be  initialized .  The expression between the brackets specifies the  dimension  of\nthe pool.  Examples:  code/await Play (...) do ... end\npool[10] Play plays;        // \"plays\" is a static pool of 10 elements max\npool&[]  Play a = &plays;   // \"a\" is an alias to \"plays\"   TODO: data pools",
            "title": "Pools"
        },
        {
            "location": "/statements/#dimension",
            "text": "Declarations for  vectors  or  pools  require an expression\nbetween brackets to specify a dimension as follows:   constant expression : Maximum number of elements is fixed and space is\n                         statically pre-allocated.  variable expression : Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.  omitted : Maximum number of elements is unbounded and space is dynamically\n             allocated.\n             The space for dynamic dimensions grow and shrink automatically.  TODO: ring buffers",
            "title": "Dimension"
        },
        {
            "location": "/statements/#events",
            "text": "An  event  declaration specifies a type  for the values it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.",
            "title": "Events"
        },
        {
            "location": "/statements/#external-events",
            "text": "Examples:  input  none A;          // \"A\" is an input event carrying no values\noutput int  MY_EVT;     // \"MY_EVT\" is an output event carrying integer values\ninput (int,byte&&) BUF; // \"BUF\" is an input event carrying an \"(int,byte&&)\" pair  TODO: output &/impl",
            "title": "External Events"
        },
        {
            "location": "/statements/#internal-events",
            "text": "Declarations for internal events can also be aliases .\nOnly in this case they can be  initialized .  Examples:  event  none a;          // \"a\" is an internal events carrying no values\nevent& none z = &a;     // \"z\" is an alias to event \"a\"\nevent (int,int) c;      // \"c\" is a internal event carrying an \"(int,int)\" pair",
            "title": "Internal Events"
        },
        {
            "location": "/statements/#assignments",
            "text": "An assignment associates the statement or expression at the right side of the\nsymbol  =  with the  location(s)  at the left side:  Assignment ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n\nSources ::= ( Do\n            | Emit_Ext\n            | Await\n            | Watching\n            | Thread\n            | Lua_Stmts\n            | Code_Await\n            | Code_Spawn\n            | Vec_Cons\n            | Data_Cons\n            | Exp\n            | `_\u00b4 )  C\u00e9u supports the following constructs as assignment sources:   do-end  block  external emit  await  watching statement  thread  lua statement  code await  code spawn  vector  length  &  constructor  data constructor  expression  the special identifier  _   The special identifier  _  makes the assignment innocuous.\nIn the case of assigning to an  option type , the  _  unsets\nit.  TODO: required for uninitialized variables",
            "title": "Assignments"
        },
        {
            "location": "/statements/#copy-assignment",
            "text": "A  copy assignment  evaluates the statement or expression at the right side and\ncopies the result(s) to the location(s) at the left side.",
            "title": "Copy Assignment"
        },
        {
            "location": "/statements/#alias-assignment",
            "text": "An  alias assignment , aka  binding , makes the location at the left side to be\nan  alias  to the expression at the right side.  The right side of a binding must always be prefixed with the operator  & .",
            "title": "Alias Assignment"
        },
        {
            "location": "/statements/#event-handling",
            "text": "",
            "title": "Event Handling"
        },
        {
            "location": "/statements/#await",
            "text": "The  await  statement halts the running trail until the specified event occurs.\nThe event can be an  input event , an internal event , a terminating code abstraction , a timer, a pausing event , or forever (i.e., never awakes):  Await ::= await (ID_ext | Loc) [until Exp]      /* events and option aliases */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */  Examples:  await A;                  // awaits the input event \"A\"\nawait a until v==10;      // awaits the internal event \"a\" until the condition is satisfied\n\nvar&? My_Code my = <...>; // acquires a reference to a code abstraction instance\nawait my;                 // awaits it terminate\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable \"t\" in milliseconds\n\nawait FOREVER;            // awaits forever  An  await  evaluates to zero or more values which can be captured with an\noptional  assignment .",
            "title": "Await"
        },
        {
            "location": "/statements/#event",
            "text": "The  await  statement for events halts the running trail until the specified input event  or internal event  occurs.\nThe  await  evaluates to a value of the type of the event.  The optional clause  until  tests an awaking condition.\nThe condition can use the returned value from the  await .\nIt expands to a  loop  as follows:  loop do\n    <ret> = await <evt>;\n    if <Exp> then   // <Exp> can use <ret>\n        break;\n    end\nend  Examples:  input int E;                    // \"E\" is an input event carrying \"int\" values\nvar int v = await E until v>10; // assigns occurring \"E\" to \"v\", awaking only when \"v>10\"\n\nevent (bool,int) e;             // \"e\" is an internal event carrying \"(bool,int)\" pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on \"e\" and assigns its values to \"v1\" and \"v2\"",
            "title": "Event"
        },
        {
            "location": "/statements/#code-abstraction",
            "text": "The  await  statement for a  code abstraction  halts the running trail\nuntil the specified instance terminates.  The  await  evaluates to the return value of the abstraction.  TODO: option return on kill  Example:  var&? My_Code my = spawn My_Code();\nvar? int ret = await my;",
            "title": "Code Abstraction"
        },
        {
            "location": "/statements/#timer",
            "text": "The  await  statement for timers halts the running trail until the specified\ntimer expires:   WCLOCKK  specifies a constant timer expressed as a sequence of value/unit\n  pairs.  WCLOCKE  specifies an  integer  expression in\n  parenthesis followed by a single unit of time.   The  await  evaluates to a value of type  s32  and is the residual delta time ( dt )  measured in microseconds:\n    the difference between the actual elapsed time and the requested time.\nThe residual  dt  is always greater than or equal to 0.  If a program awaits timers in sequence (or in a  loop ), the residual  dt  from\nthe preceding timer is reduced from the timer in sequence.  Examples:  var int t = <...>;\nawait (t)ms;                // awakes after \"t\" milliseconds  var int dt = await 100us;   // if 1000us elapses, then dt=900us (1000-100)\nawait 100us;                // since dt=900, this timer is also expired, now dt=800us (900-100)\nawait 1ms;                  // this timer only awaits 200us (1000-800)",
            "title": "Timer"
        },
        {
            "location": "/statements/#pausing",
            "text": "Pausing events are dicussed in  Pausing .",
            "title": "Pausing"
        },
        {
            "location": "/statements/#forever",
            "text": "The  await  statement for  FOREVER  halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.  Example:  if v==10 then\n    await FOREVER;  // this trail never awakes if condition is true\nend",
            "title": "FOREVER"
        },
        {
            "location": "/statements/#emit",
            "text": "The  emit  statement broadcasts an event to the whole program.\nThe event can be an  external event , an internal event , or a timer:  Emit_Int ::= emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\nEmit_Ext ::= emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n          |  emit (WCLOCKK|WCLOCKE)  Examples:  emit A;         // emits the output event `A` of type \"none\"\nemit a(1);      // emits the internal event `a` of type \"int\"\n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds",
            "title": "Emit"
        },
        {
            "location": "/statements/#events_1",
            "text": "The  emit  statement for events expects the arguments to match the event type.  An  emit  to an input or timer event can only occur inside asynchronous blocks .  An  emit  to an output event is also an expression that evaluates to a value of\ntype  s32  and can be captured with an optional  assignment  (its\nmeaning is platform dependent).  An  emit  to an internal event starts a new internal reaction .  Examples:  input int I;\nasync do\n    emit I(10);         // broadcasts \"I\" to the application itself, passing \"10\"\nend\n\noutput none O;\nvar int ret = emit O(); // outputs \"O\" to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts \"e\" passing a pair of \"int\" values",
            "title": "Events"
        },
        {
            "location": "/statements/#timer_1",
            "text": "The  emit  statement for timers expects a  timer expression .  Like input events, time can only be emitted inside  asynchronous \nblocks .  Examples:  async do\n    emit 1s;    // broadcasts \"1s\" to the application itself\nend",
            "title": "Timer"
        },
        {
            "location": "/statements/#lock",
            "text": "TODO",
            "title": "Lock"
        },
        {
            "location": "/statements/#conditional",
            "text": "The  if-then-else  statement provides conditional execution in C\u00e9u:  If ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end  Each condition  Exp  is tested in sequence, first for the  if  clause and then\nfor each of the optional  else/if  clauses.\nOn the first condition that evaluates to  true , the  Block  following it\nexecutes.\nIf all conditions fail, the optional  else  clause executes.  All conditions must evaluate to a value of type  bool .",
            "title": "Conditional"
        },
        {
            "location": "/statements/#loops",
            "text": "C\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:  Loop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] NumericRange do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\nNumericRange ::= /* (see \"Numeric Iterator\") */  The body of a loop  Block  executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.  Except for the  every  iterator, all loops support an optional constant\nexpression  `/\u00b4Exp  that limits the maximum number of\niterations to avoid  infinite execution .\nIf the number of iterations reaches the limit, a runtime error occurs.",
            "title": "Loops"
        },
        {
            "location": "/statements/#break-and-continue",
            "text": "The  break  statement aborts the deepest enclosing loop.  The  continue  statement aborts the body of the deepest enclosing loop and\nrestarts it in the next iteration.  The optional modifier  `/\u00b4ID_int  in both statements\nonly applies to  numeric iterators .",
            "title": "break and continue"
        },
        {
            "location": "/statements/#simple-loop",
            "text": "The simple  loop-do-end  statement executes its body forever:  SimpleLoop ::= loop [`/\u00b4Exp] do\n                   Block\n               end  The only way to terminate a simple loop is with the  break  statement.  Examples:  // blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend  loop do\n    loop do\n        if <cnd-1> then\n            break;      // aborts the loop at line 2 if <cnd-1> is satisfied\n        end\n    end\n    if <cnd-2> then\n        continue;       // restarts the loop at line 1 if <cnd-2> is satisfied\n    end\nend",
            "title": "Simple Loop"
        },
        {
            "location": "/statements/#numeric-iterator",
            "text": "The numeric loop executes its body a fixed number of times based on a numeric\nrange for a control variable:  NumericIterator ::= loop [`/\u00b4Exp] NumericRange do\n                        Block\n                    end\n\nNumericRange ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                       ( (     Exp `->\u00b4 (`_\u00b4|Exp))\n                                       | (`_\u00b4|Exp) `<-\u00b4 Exp      ) )\n                                   (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]  The control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:   control variable: \n     ID_int  is a read-only variable of a  numeric type .\n    Alternatively, the special anonymous identifier  _  can be used if the body\n    of the loop does not access the variable.   interval: \n    Specifies a direction, endpoints with open or closed modifiers, and a step.   direction :  -> : Starts from the endpoint  Exp  on the left increasing towards  Exp  on the right.  <- : Starts from the endpoint  Exp  on the right decreasing towards  Exp  on the left.\nTypically, the value on the left is smaller or equal to the value on\nthe right.    endpoints :\n     [Exp  and  Exp]  are closed intervals which include  Exp  as the\n    endpoints;\n     ]Exp  and  Exp[  are open intervals which exclude  Exp  as the\n    endpoints.\n    Alternatively, the finishing endpoint may be  _  which means that the\n    interval goes towards infinite.  step :\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value  1 .\n    If the direction is  -> , the step is added, otherwise it is subtracted.   If the interval is not specified, it assumes the default  [0 -> _[ .    A numeric iterator executes as follows:    initialization: \n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step\n    immediately.    iteration:   limit check: \n    If the control variable crossed the finishing endpoint, the loop\n    terminates.  body execution: \n    The loop body executes.  step \n    Applies a step to the control variable. Goto step  1 .     The  break  and  continue  statements inside numeric iterators accept an\noptional modifier  `/\u00b4ID_int  to affect the enclosing\nloop matching the control variable.  Examples:  // prints \"i=0\", \"i=1\", ...\nvar int i;\nloop i do\n    _printf(\"i=%d\\n\", i);\nend  // awaits 1s and prints \"Hello World!\" 10 times\nloop _ in [0 -> 10[ do\n    await 1s;\n    _printf(\"Hello World!\\n\");\nend  var int i;\nloop i do\n    var int j;\n    loop j do\n        if <cnd-1> then\n            continue/i;         // continues the loop at line 1\n        else/if <cnd-2> then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend  Note : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.",
            "title": "Numeric Iterator"
        },
        {
            "location": "/statements/#event-iterator",
            "text": "The  every  statement iterates over an event continuously, executing its\nbody whenever the event occurs:  EventIterator ::= every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n                      Block\n                  end  The event can be an  external or internal event  or a  timer .  The optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.  An  every  expands to a  loop  as illustrated below:  every <vars> in <event> do\n    <body>\nend  is equivalent to  loop do\n    <vars> = await <event>;\n    <body>\nend  However, the body of an  every  cannot contain synchronous control statements , ensuring\nthat no occurrences of the specified event are ever missed.  TODO: reject break inside every  Examples:  every 1s do\n    _printf(\"Hello World!\\n\");      // prints the \"Hello World!\" message on every second\nend  event (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received \"cnd\" is false\n    else\n        _printf(\"v = %d\\n\", v);     // prints the received \"v\" otherwise\n    end\nend",
            "title": "Event Iterator"
        },
        {
            "location": "/statements/#pool-iterator",
            "text": "The  pool  iterator visits all alive abstraction  instances residing in a given pool:  PoolIterator ::= loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n                     Block\n                 end  On each iteration, the optional control variable becomes a reference  to an instance, starting from the oldest created\nto the newest.  The control variable must be an alias to the same type of the pool with the\nsame rules that apply to  spawn .  Examples:  pool[] My_Code my_codes;\n\n<...>\n\nvar&? My_Code my_code;\nloop my_code in mycodes do\n    <...>\nend",
            "title": "Pool Iterator"
        },
        {
            "location": "/statements/#parallel-compositions",
            "text": "Pars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nSpawn ::= spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n              Block\n          end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Abs_Cons) do\n                 Block\n             end  The parallel statements  par/and ,  par/or , and  par  fork the running trail \nin multiple others.\nThey differ only on how trails rejoin and terminate the composition.  The  spawn  statement starts to execute a block in parallel with the enclosing\nblock.  The  watching  statement executes a block and terminates when one of its\nspecified events occur.  See also  Parallel Compositions and Abortion .",
            "title": "Parallel Compositions"
        },
        {
            "location": "/statements/#par",
            "text": "The  par  statement never rejoins.  Examples:  // reacts continuously to \"1s\" and \"KEY_PRESSED\" and never terminates\ninput none KEY_PRESSED;\npar do\n    every 1s do\n        <...>           // does something every \"1s\"\n    end\nwith\n    every KEY_PRESSED do\n        <...>           // does something every \"KEY_PRESSED\"\n    end\nend",
            "title": "par"
        },
        {
            "location": "/statements/#parand",
            "text": "The  par/and  statement stands for  parallel-and  and rejoins when all nested\ntrails terminate.  Examples:  // reacts once to \"1s\" and \"KEY_PRESSED\" and terminates\ninput none KEY_PRESSED;\npar/and do\n    await 1s;\n    <...>               // does something after \"1s\"\nwith\n    await KEY_PRESSED;\n    <...>               // does something after \"KEY_PRESSED\"\nend",
            "title": "par/and"
        },
        {
            "location": "/statements/#paror",
            "text": "The  par/or  statement stands for  parallel-or  and rejoins when any of the \ntrails terminate, aborting all other trails.  Examples:  // reacts once to `1s` or `KEY_PRESSED` and terminates\ninput none KEY_PRESSED;\npar/or do\n    await 1s;\n    <...>               // does something after \"1s\"\nwith\n    await KEY_PRESSED;\n    <...>               // does something after \"KEY_PRESSED\"\nend",
            "title": "par/or"
        },
        {
            "location": "/statements/#spawn",
            "text": "The  spawn  statement starts to execute a block in parallel with the enclosing\nblock.\nWhen the enclosing block terminates, the spawned block is aborted.  Like a  do-end  block , a  spawn  also supports an\noptional list of identifiers in parenthesis which restricts the visible\nvariables inside the block to those matching the list.  Examples:  spawn do\n    every 1s do\n        <...>       // does something every \"1s\"...\n    end\nend\n\n<...>               // ...in parallel with whatever comes next",
            "title": "spawn"
        },
        {
            "location": "/statements/#watching",
            "text": "A  watching  expands to a  par/or  with  n+1  trails:\none to await each of the listed events,\nand one to execute its body, i.e.:  watching <e1>,<e2>,... do\n    <body>\nend  expands to  par/or do\n    await <e1>;\nwith\n    await <e2>;\nwith\n    ...\nwith\n    <body>\nend  The  watching  statement accepts a list of events and terminates when any of\nthem occur.\nThe events are the same supported by the  await  statement.\nIt evaluates to what the occurring event value(s), which can be captured with\nan optional  assignment .  If the event is a  code abstraction , the nested blocked does not\nrequire the unwrap operator  ! .  Examples:  // reacts continuously to \"KEY_PRESSED\" during \"1s\"\ninput none KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n        <...>           // does something every \"KEY_PRESSED\"\n    end\nend",
            "title": "watching"
        },
        {
            "location": "/statements/#pausing_1",
            "text": "The  pause/if  statement controls if its body should temporarily stop to react\nto events:  Pause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)  A  pause/if  specifies a pausing event of type  bool  which, when emitted,\ntoggles between pausing ( true ) and resuming ( false ) reactions for its body.  When its body terminates, the whole  pause/if  terminates and proceeds to the\nstatement in sequence.  In transition instants, the body can react to the special  pause  and  resume \nevents before the corresponding state applies.  TODO: finalize/pause/resume  Examples:  event bool e;\npause/if e do       // pauses/resumes the nested body on each \"e\"\n    every 1s do\n        <...>       // does something every \"1s\"\n    end\nend  event bool e;\npause/if e do               // pauses/resumes the nested body on each \"e\"\n    <...>\n        loop do\n            await pause;\n            <...>           // does something before pausing\n            await resume;\n            <...>           // does something before resuming\n        end\n    <...>\nend",
            "title": "Pausing"
        },
        {
            "location": "/statements/#exceptions",
            "text": "TODO  Throw ::= throw Exp\nCatch ::= catch LIST(Loc) do\n              Block\n          end",
            "title": "Exceptions"
        },
        {
            "location": "/statements/#asynchronous-execution",
            "text": "Asynchronous execution allow programs to departure from the rigorous\nsynchronous model and preform computations under separate scheduling rules.  C\u00e9u supports  asynchronous blocks ,  threads , and interrupt service routines :  Async  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nIsr ::= spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\nAtomic ::= atomic do\n               Block\n           end  Asynchronous execution supports  tight loops  while\nkeeping the rest of the application, aka the  synchronous side , reactive to\nincoming events.  However, it does not support any synchronous control statement  (e.g.,\nparallel compositions, event handling, pausing, etc.).  By default, asynchronous bodies do not share variables with their enclosing\nscope, but the optional list of variables makes them visible to the block.  Even though asynchronous blocks execute in separate, they are still managed by\nthe program hierarchy and are also subject to lexical scope and abortion.",
            "title": "Asynchronous Execution"
        },
        {
            "location": "/statements/#asynchronous-block",
            "text": "Asynchronous blocks, aka  asyncs , intercalate execution with the synchronous\nside as follows:   Start/Resume whenever the synchronous side is idle.\n   When multiple  asyncs  are active, they execute in lexical order.  Suspend after each  loop  iteration.  Suspend on every input  emit  (see  Simulation ).  Execute atomically and to completion unless rules  2  and  3  apply.   This rules imply that  asyncs  never execute with real parallelism with the\nsynchronous side, preserving determinism in the program.  Examples:  // calculates the factorial of some \"v\" if it doesn't take too long\nvar u64  v   = <...>;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps \"v\" and \"fat\" visible\n        loop i in [1 -> v] do   // reads from \"v\"\n            fat = fat * i;      // writes to \"fat\"\n        end\n    end\n    ok = true;                  // completed within \"1s\"\nend",
            "title": "Asynchronous Block"
        },
        {
            "location": "/statements/#simulation",
            "text": "An  async  block can emit  input and timer events  towards the\nsynchronous side, providing a way to test programs in the language itself.\nEvery time an  async  emits an event, it suspends until the synchronous side\nreacts to the event (see  rule 1  above).  Examples:  input int A;\n\n// tests a program with input simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -> _[ do\n        await 10ms;\n        _printf(\"v = %d\\n\", v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for \"v\"\n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v = <v+i>` exactly 103 times.",
            "title": "Simulation"
        },
        {
            "location": "/statements/#thread",
            "text": "Threads provide real parallelism for applications in C\u00e9u.\nOnce started, a thread executes completely detached from the synchronous side.\nFor this reason, thread execution is non deterministic and require explicit atomic blocks  on accesses to variables to avoid race\nconditions.  A thread evaluates to a boolean value which indicates whether it started\nsuccessfully or not.\nThe value can be captured with an optional  assignment .  Examples:  // calculates the factorial of some \"v\" if it doesn't take too long\nvar u64  v   = <...>;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps \"v\" and \"fat\" visible\n        loop i in [1 -> v] do       // reads from \"v\"\n            fat = fat * i;          // writes to \"fat\"\n        end\n    end\n    ok = true;                      // completed within \"1s\"\nend",
            "title": "Thread"
        },
        {
            "location": "/statements/#asynchronous-interrupt-service-routine",
            "text": "TODO",
            "title": "Asynchronous Interrupt Service Routine"
        },
        {
            "location": "/statements/#atomic-block",
            "text": "Atomic blocks provide mutual exclusion among threads, interrupts, and the\nsynchronous side of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.  Examples:  // A \"race\" between two threads: one incrementing, the other decrementing \"count\".\n\nvar s64 count = 0;                              // \"count\" is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf(\"count = %d\\n\", count);     // prints current value of \"count\" every \"1s\"\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements \"count\" as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments \"count\" as fast as possible\n            end\n        end\n    end\nend",
            "title": "Atomic Block"
        },
        {
            "location": "/statements/#c-integration",
            "text": "C\u00e9u provides  native declarations  to import C symbols, native blocks  to define new code in C, native statements  to inline C statements, native calls  to call C functions,\nand  finalization  to deal with C pointers safely:  Nat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 LIST(ID_nat) `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                   <code definitions in C>\n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 {<code in C> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nFinalization ::= do [Stmt] Finalize\n              |  var [`&\u00b4|`&?\u00b4] Type ID_int `=\u00b4 `&\u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize [ `(\u00b4 LIST(Loc) `)\u00b4 ] with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end  Native calls and statements transfer execution to C, losing the guarantees of\nthe  synchronous model .\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple  struct  accessors, but\nnever for control purposes.  TODO: Nat_End",
            "title": "C Integration"
        },
        {
            "location": "/statements/#native-declaration",
            "text": "In C\u00e9u, any  identifier  prefixed with an\nunderscore is a native symbol defined externally in C.\nHowever, all external symbols must be declared before their first use in a\nprogram.  Native declarations support four modifiers as follows:   const : declares the listed symbols as constants.\n    Constants can be used as bounded limits in  vectors ,\n     pools , and  numeric loops .\n    Also, constants cannot be  assigned .  plain : declares the listed symbols as  plain  types, i.e., types (or\n    composite types) that do not contain pointers.\n    A value of a plain type passed as argument to a function does not require\n     finalization .  nohold : declares the listed symbols as  non-holding  functions, i.e.,\n    functions that do not retain received pointers after returning.\n    Pointers passed to non-holding functions do not require\n     finalization .  pure : declares the listed symbols as pure functions.\n    In addition to the  nohold  properties, pure functions never allocate\n    resources that require  finalization \n    and have no side effects to take into account for the  safety checks .   Examples:  // values\nnative/const  _LOW, _HIGH;      // Arduino \"LOW\" and \"HIGH\" are constants\nnative        _errno;           // POSIX \"errno\" is a global variable\n\n// types\nnative/plain  _char;            // \"char\" is a \"plain\" type\nnative        _SDL_PixelFormat; // SDL \"SDL_PixelFormat\" is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv \"uv_read_start\" retains the received pointer\nnative/nohold _free;            // POSIX \"free\" receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX \"strlen\" is a \"pure\" function",
            "title": "Native Declaration"
        },
        {
            "location": "/statements/#native-block",
            "text": "A native block allows programs to define new external symbols in C.  The contents of native blocks is copied unchanged to the output in C depending\non the modifier specified:   pre : code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in  pre  blocks are visible to C\u00e9u.  pos : code is placed after the declarations for the C\u00e9u program.\n    Symbols implicitly defined by the compiler of C\u00e9u are visible to  pos \n    blocks.   Native blocks are copied in the order they appear in the source code.  Since C\u00e9u uses the  C preprocessor , hash\ndirectives  #  inside native blocks must be quoted as  ##  to be considered\nonly in the C compilation phase.  If the code in C contains the terminating  end  keyword of C\u00e9u, the  native \nblock should be delimited with matching comments to avoid confusing the parser:  Symbols defined in native blocks still need to be declared  for use in the program.  Examples:  native/plain _t;\nnative/pre do\n    typedef int t;              // definition for \"t\" is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires \"t\" to be already defined  input none A;                   // declaration for \"A\" is placed before \"pos\" blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires \"A\" to be already declared\n    }\nend  native/nohold _printf;\nnative/pre do\n    ##include <stdio.h>         // include the relevant header for \"printf\"\nend  native/pos do\n    /******/\n    char str = \"This `end` confuses the parser\";\n    /******/\nend",
            "title": "Native Block"
        },
        {
            "location": "/statements/#native-statement",
            "text": "The contents of native statements in between  {  and  }  are inlined in the\nprogram.  Native statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by the symbol  @ .  Examples:  var int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf(\"%d\\n\", @v_ceu);     // prints 30\n}",
            "title": "Native Statement"
        },
        {
            "location": "/statements/#native-call",
            "text": "Expressions that evaluate to a  native type  can be called\nfrom C\u00e9u.  If a call passes or returns pointers, it may require an accompanying finalization statement .  Examples:  // all expressions below evaluate to a native type and can be called\n\n_printf(\"Hello World!\\n\");\n\nvar _t f = <...>;\nf();\n\nvar _s s = <...>;\ns.f();",
            "title": "Native Call"
        },
        {
            "location": "/statements/#resources-finalization",
            "text": "A finalization statement unconditionally executes a series of statements when\nits associated block terminates or is aborted.  C\u00e9u tracks the interaction of native calls with pointers and requires  finalize  clauses to accompany the calls:   If C\u00e9u  passes  a pointer to a native call, the pointer represents a\n   local resource  that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.  If C\u00e9u  receives  a pointer from a native call return, the pointer\n  represents an  external resource  that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.   In both cases, the program does not compile without the  finalize  statement.  A  finalize  cannot contain synchronous control statements .  Examples:  // Local resource finalization\nwatching <...> do\n    var _buffer_t msg;\n    <...>                       // prepares msg\n    do\n        _send_request(&&msg);\n    finalize with\n        _send_cancel(&&msg);\n    end\n    await SEND_ACK;             // transmission is complete\nend  In the example above, the local variable  msg  is an internal resource passed\nas a pointer to  _send_request , which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing  watching  aborts before awaking from the  await SEND_ACK ,\nthe local  msg  goes out of scope and the external transmission would hold a dangling pointer .\nThe  finalize  ensures that  _send_cancel  also aborts the transmission.  // External resource finalization\nwatching <...> do\n    var&? _FILE f = &_fopen(<...>) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite(<...>, f);\n    await A;\n    _fwrite(<...>, f);\nend  In the example above, the call to  _fopen  returns an external file resource as\na pointer.\nIf the enclosing  watching  aborts before awaking from the  await A , the file\nwould remain open as a  memory leak .\nThe  finalize  ensures that  _fclose  closes the file properly.  To access an external resource from C\u00e9u requires an alias assignment  to a variable alias .\nIf the external call returns  NULL  and the variable is an option alias var&? , the alias remains unbounded.\nIf the variable is an alias  var& , the assigment raises a runtime error.  Note: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.  Declaration  and  expression \nmodifiers may suppress the requirement for finalization in calls:   nohold  modifiers or  /nohold  typecasts make passing pointers safe.  pure    modifiers or  /pure    typecasts make passing pointers and returning\n                                  pointers safe.  /plain  typecasts make return values safe.   Examples:  // \"_free\" does not retain \"ptr\"\nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);  // \"_strchr\" does retain \"ptr\" or allocates resources\nnative/pure _strchr;\nvar _char&& found = _strchr(ptr);\n// or\nvar _char&& found = (_strchr as /pure)(ptr);  // \"_f\" returns a non-pointer type\nvar _tp v = _f() as /plain;",
            "title": "Resources &amp; Finalization"
        },
        {
            "location": "/statements/#lua-integration",
            "text": "C\u00e9u provides  Lua states  to delimit the effects of inlined Lua statements .\nLua statements transfer execution to the Lua runtime, losing the guarantees of\nthe  synchronous model :  Lua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { {<code in Lua> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n              `]\u00b4 {`=\u00b4} `]\u00b4  Programs have an implicit enclosing  global Lua state  which all orphan\nstatements apply.",
            "title": "Lua Integration"
        },
        {
            "location": "/statements/#lua-state",
            "text": "A Lua state creates an isolated state for inlined Lua statements .  Example:  // \"v\" is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend  TODO: dynamic scope, assignment/error, [dim]",
            "title": "Lua State"
        },
        {
            "location": "/statements/#lua-statement",
            "text": "The contents of Lua statements in between  [[  and  ]]  are inlined in the\nprogram.  Like  native statements , Lua statements support\ninterpolation of expressions in C\u00e9u which are expanded when preceded by a  @ .  Lua statements only affect the  Lua state  in which they are embedded.  If a Lua statement is used in an  assignment , it is evaluated as\nan expression that either satisfies the destination or generates a runtime\nerror.\nThe list that follows specifies the  C\u00e9u destination  and expected Lua source :   a  boolean   variable \n    expects a  boolean  value  a  numeric   variable \n    expects a  number  value  a  pointer   variable \n    expects a  lightuserdata  value  a  byte   vector \n    expects a  string  value   TODO: lua state captures errors  Examples:  var int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]",
            "title": "Lua Statement"
        },
        {
            "location": "/statements/#abstractions",
            "text": "C\u00e9u supports reuse with  data  declarations to define new types, and  code \ndeclarations to define new subprograms.  Declarations are subject to  lexical scope .",
            "title": "Abstractions"
        },
        {
            "location": "/statements/#data",
            "text": "A  data  declaration creates a new data type:  Data ::= data ID_abs [as (nothing|Exp)] [ with\n             (Var|Vec|Pool|Int) `;\u00b4 { (Var|Vec|Pool|Int) `;\u00b4 }\n         end\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4  A declaration may pack fields with storage declarations  which become publicly\naccessible in the new type.\nField declarations may  assign  default values for\nuninitialized instances.  Data types can form hierarchies using dots ( . ) in identifiers:   An isolated identifier such as  A  makes  A  a base type.  A dotted identifier such as  A.B  makes  A.B  a subtype of its supertype  A .   A subtype inherits all fields from its supertype.  The optional modifier  as  expects the keyword  nothing  or a constant\nexpression of type  int :   nothing : the  data  cannot be instantiated.  constant expression :  typecasting  a value of\n                         the type to  int  evaluates to the specified\n                         enumeration expression.   Examples:  data Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  // \"r.z\" defaults to 0  data Dir       as nothing;  // \"Dir\" is a base type and cannot be intantiated\ndata Dir.Right as  1;       // \"Dir.Right\" is a subtype of \"Dir\"\ndata Dir.Left  as -1;       // \"Dir.Left\"  is a subtype of \"Dir\"\nvar  Dir dir = <...>;       // receives one of \"Dir.Right\" or \"Dir.Left\"\nescape (dir as int);        // returns 1 or -1  TODO: new, pool, recursive types",
            "title": "Data"
        },
        {
            "location": "/statements/#data-constructor",
            "text": "A new data value is created in the contexts that follow:   Prefixed by the keyword  val  in an  assignment  to a variable.  As an argument to a  code  invocation .  Nested as an argument in a  data  creation (i.e., a  data  that contains\n  another  data ).   In all cases, the arguments are copied to the destination.\nThe destination must be a plain declaration (i.e., not an alias or pointer).  The constructor uses the  data  identifier followed by a list of arguments\nmatching the fields of the type.  Variables of the exact same type can be copied in  assignments .  For assignments from a subtype to a supertype, the rules are as follows:   Copy assignments  plain values: only if the subtype contains no extra fields  pointers: allowed    Alias assignment : allowed.   data Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());  var Object o2 = o1;         // makes a deep copy of all fields from \"o1\" to \"o2\"",
            "title": "Data Constructor"
        },
        {
            "location": "/statements/#code",
            "text": "The  code/tight  and  code/await  declarations specify new subprograms that can\nbe invoked from arbitrary points in programs:  // prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `->\u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4\n                                        [ `->\u00b4 `(\u00b4 Params `)\u00b4 ]\n                                            `->\u00b4 (Type | NEVER)\n                    [ throws LIST(ID_abs) ]\nParams ::= none | LIST(Var|Vec|Pool|Int)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Abs_Cons\nCode_Spawn ::= spawn Mods Abs_Cons [in Loc]\nCode_Kill  ::= kill Loc [ `(` Exp `)` ]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]  A  code/tight  is a subprogram that cannot contain synchronous control statements  and its body\nruns to completion in the current  internal reaction .  A  code/await  is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its body execution may outlive\nmultiple reactions.  A  prototype declaration  specifies the interface parameters of the\nabstraction which invocations must satisfy.\nA  full declaration  (aka  definition ) also specifies an implementation\nwith a block of code.\nAn  invocation  specifies the name of the code abstraction and arguments\nmatching its declaration.  Declarations can be nested.\nA nested declaration is not visible outside its enclosing declaration.\nThe body of a nested declaration may access entities from its enclosing\ndeclarations with the prefix  outer .  To support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier  /recursive .  Examples:  code/tight Absolute (var int v) -> int do   // declares the prototype for \"Absolute\"\n    if v > 0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes \"Absolute\" (yields 10)  code/await Hello_World (none) -> NEVER do\n    every 1s do\n        _printf(\"Hello World!\\n\");  // prints \"Hello World!\" every second\n    end\nend\nawait Hello_World();                // never awakes  code/tight/recursive Fat (var int v) -> int;    // \"Fat\" is a recursive code\ncode/tight/recursive Fat (var int v) -> int do\n    if v > 1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes \"Fat\" (yields 3628800)  TODO: hold",
            "title": "Code"
        },
        {
            "location": "/statements/#code-declaration",
            "text": "Code abstractions specify a list of input parameters in between the symbols (  and  ) .\nEach parameter specifies an  entity class \nwith modifiers, a type and an identifier.\nA  none  list specifies that the abstraction has no parameters.  Code abstractions also specify an output return type.\nA  code/await  may use  NEVER  as output to indicate that it never returns.  A  code/await  may also specify an optional  public field list , which are\nlocal storage entities living in the outermost scope of the abstraction body.\nThese entities are visible to the invoking context, which may access  them while the abstraction executes.\nLikewise, nested code declarations in the outermost scope, known as methods,\nare also visible to the invoking context.  TODO: throws",
            "title": "Code Declaration"
        },
        {
            "location": "/statements/#code-invocation",
            "text": "A  code/tight  is invoked with the keyword  call  followed by the abstraction\nname and list of arguments.\nA  code/await  is invoked with the keywords  await  or  spawn  followed by the\nabstraction name and list of arguments.  The list of arguments must satisfy the list of parameters in the code declaration .  The  call  and  await  invocations suspend the current trail and transfer\ncontrol to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of its return type which can be captured with an optional assignment .  The  spawn  invocation also suspends and transfers control to the code\nabstraction.\nHowever, as soon as the abstraction becomes idle (or terminates), the invoking\npoint resumes.\nThis makes the invocation point and abstraction to execute concurrently.  The  spawn  invocation evaluates to a  reference \nrepresenting the instance and can be captured with an optional assignment .\nThe alias must be an  option alias variable  of\nthe same type of the code abstraction.\nIf the abstraction never terminates (i.e., return type is  NEVER ), the\nvariable may be a simple alias.\nIf the  spawn  fails (e.g., lack of memory) the option alias variable is unset.\nIn the case of a simple alias, the assignment raises a runtime error.  The  spawn  invocation also accepts an optional  pool  which provides\nstorage and scope for invoked abstractions.\nWhen the pool goes out of scope, all invoked abstractions residing in that pool\nare aborted.\nIf the  spawn  omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is also aborted.  TODO: kill",
            "title": "Code Invocation"
        },
        {
            "location": "/statements/#code-references",
            "text": "The  spawn   invocation  and the control variable of pool iterators  evaluate to a reference as an option alias  to an abstraction instance.\nIf the instance terminates at any time, the option variable is automatically\nunset.  A reference provides  access  to the public fields and\nmethods of the instance.  Examples:  code/await My_Code (var int x) -> (var int y) -> NEVER do\n    y = x;                              // \"y\" is a public field\n\n    code/tight Get_X (none) -> int do   // \"Get_X\" is a public method\n        escape outer.x;\n    end\n\n    await FOREVER;\nend\n\nvar& My_Code c = spawn My_Code(10);\n_printf(\"y=%d, x=%d\\n\", c.y, c.Get_X());    // prints \"y=10, x=10\"",
            "title": "Code References"
        },
        {
            "location": "/statements/#dynamic-dispatching",
            "text": "C\u00e9u supports dynamic code dispatching based on multiple parameters.  The modifier  /dynamic  in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one  dynamic  parameter.\nAlso, all dynamic parameters must be pointers or aliases to a data type  in some hierarchy.  A dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the  dynamic  parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.  To determine which declaration to execute during runtime, the actual argument\nruntime type is checked against the first formal  dynamic  parameter of each\ndeclaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.  A  catchall  declaration with the most general dynamic types must always be\nprovided.  If the argument is explicitly  typecast  to a\nsupertype, then dispatching considers that type instead.  Example:  data Media as nothing;\ndata Media.Audio     with <...> end\ndata Media.Video     with <...> end\ndata Media.Video.Avi with <...> end\n\ncode/await/dynamic Play (dynamic var& Media media) -> none do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var& Media.Audio media) -> none do\n    <...>                   // plays an audio\nend\ncode/await/dynamic Play (dynamic var& Media.Video media) -> none do\n    <...>                   // plays a video\nend\ncode/await/dynamic Play (dynamic var& Media.Video.Avi media) -> none do\n    <...>                                   // prepare the avi video\n    await/dynamic Play(&m as Media.Video);  // dispatches the supertype\nend\n\nvar& Media m = <...>;       // receives one of \"Media.Audio\" or \"Media.Video\"\nawait/dynamic Play(&m);     // dispatches the appropriate subprogram to play the media",
            "title": "Dynamic Dispatching"
        },
        {
            "location": "/statements/#synchronous-control-statements",
            "text": "The  synchronous control statements  which follow cannot appear in event iterators , pool iterators , asynchronous execution , finalization ,\nand tight code abstractions : await ,  spawn ,  emit  (internal events),  every ,  finalize ,  pause/if , par ,  par/and ,  par/or , and  watching .  As exceptions, an  every  can  emit  internal events, and a  code/tight  can\ncontain empty  finalize  statements.",
            "title": "Synchronous Control Statements"
        },
        {
            "location": "/expressions/",
            "text": "Locations & Expressions\n\u00b6\n\n\nC\u00e9u specifies \nlocations\n and expressions as\nfollows:\n\n\nExp ::= NUM | STR | null | true | false | on | off | yes | no\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp <binop> Exp\n     |  <unop> Exp\n     |  Exp (`:\u00b4|`.\u00b4) (ID_int|ID_nat)\n     |  Exp (`?\u00b4|`!\u00b4)\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp `(\u00b4 [ LIST(Exp) ] `)\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n     |  ID_int\n     |  ID_nat\n     |  outer\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 <code in C> `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    <=    >=    <     >\n    |\n    ^\n    &\n    <<    >>\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     &&    &   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n\n\n\nPrimary\n\u00b6\n\n\nTODO\n\n\nOuter\n\u00b6\n\n\nTODO\n\n\n\n\n\nArithmetic\n\u00b6\n\n\nC\u00e9u supports the arithmetic expressions \naddition\n, \nsubtraction\n,\n\nmodulo (remainder)\n, \nmultiplication\n, \ndivision\n, \nunary-plus\n, and\n\nunary-minus\n through the operators that follow:\n\n\n    +      -      %      *      /      +      -\n\n\n\n\n\n\n\nBitwise\n\u00b6\n\n\nC\u00e9u supports the bitwise expressions \nnot\n, \nand\n, \nor\n, \nxor\n, \nleft-shift\n,\nand \nright-shift\n through the operators that follow:\n\n\n    ~      &      |      ^      <<      >>\n\n\n\n\nRelational\n\u00b6\n\n\nC\u00e9u supports the relational expressions \nequal-to\n, \nnot-equal-to\n,\n\ngreater-than\n, \nless-than\n, \ngreater-than-or-equal-to\n, and\n\nless-than-or-equal-to\n through the operators that follow:\n\n\n    ==      !=      >      <      >=      <=\n\n\n\n\nRelational expressions evaluate to \ntrue\n or \nfalse\n.\n\n\nLogical\n\u00b6\n\n\nC\u00e9u supports the logical expressions \nnot\n, \nand\n, and \nor\n through the\noperators that follow:\n\n\n    not      and      or\n\n\n\n\nLogical expressions evaluate to \ntrue\n or \nfalse\n.\n\n\nTypes\n\u00b6\n\n\nC\u00e9u supports type checks and casts:\n\n\nCheck ::= Exp is Type\nCast  ::= Exp as Type\n\n\n\n\nType Check\n\u00b6\n\n\nA type check evaluates to \ntrue\n or \nfalse\n depending on whether the runtime\ntype of the expression is a subtype of the checked type or not.\n\n\nThe static type of the expression must be a supertype of the checked type.\n\n\nExample:\n\n\ndata Aa;\ndata Aa.Bb;\nvar Aa a = <...>;       // \"a\" is of static type \"Aa\"\n<...>\nif a is Aa.Bb then      // is the runtime type of \"a\" a subtype of \"Aa.Bb\"?\n    <...>\nend\n\n\n\n\nType Cast\n\u00b6\n\n\nA type cast converts the type of an expression into a new type as follows:\n\n\n\n\nThe expression type is a \ndata type\n:\n\n\nThe new type is \nint\n:\n    Evaluates to the \ntype enumeration\n for the\n    expression type.\n\n\nThe new type is a subtype of the expression static type:\n\n\nThe expression runtime type is a subtype of the new type:\n    Evaluates to the new type.\n\n\nEvaluates to error.\n\n\n\n\n\n\nThe new type is a supertype of the expression static type:\n    Always succeeds and evaluates to the new type.\n    See also \nDynamic Dispatching\n.\n\n\nEvaluates to error.\n\n\n\n\n\n\nEvaluates to the new type (i.e., a \nweak typecast\n, as in C).\n\n\n\n\nExamples:\n\n\nvar Direction dir = <...>;\n_printf(\"dir = %d\\n\", dir as int);\n\nvar Aa a = <...>;\n_printf(\"a.v = %d\\n\", (a as Aa.Bb).v);\n\nvar Media.Video vid = <...>;\nawait/dynamic Play(&m as Media);\n\nvar bool b = <...>;\n_printf(\"b= %d\\n\", b as int);\n\n\n\n\nModifiers\n\u00b6\n\n\nExpressions that evaluate to native types can be modified as follows:\n\n\nMod ::= Exp as `/\u00b4(nohold|plain|pure)\n\n\n\n\nModifiers may suppress the requirement for\n\nresource finalization\n.\n\n\nReferences\n\u00b6\n\n\nC\u00e9u supports \naliases\n and \npointers\n as\n\nreferences\n.\n\n\nAliases\n\u00b6\n\n\nAn alias is acquired by prefixing a \nnative call\n\nor a \nlocation\n with the operator \n&\n:\n\n\nAlias ::= `&\u00b4 (Nat_Call | Loc)\n\n\n\n\nSee also the \nunwrap operator\n \n!\n for option variable aliases.\n\n\nPointers\n\u00b6\n\n\nThe operator \n&&\n returns the address of a\n\nlocation\n, while the operator \n*\n dereferences\na pointer:\n\n\nAddr  ::= `&&\u00b4 Loc\nDeref ::= `*\u00b4 Loc\n\n\n\n\nOption\n\u00b6\n\n\nThe operator \n?\n checks if the \nlocation\n of an\n\noption type\n is set, while the operator \n!\n unwraps the\nlocation, raising an \nerror\n if it is unset:\n\n\nCheck  ::= Loc `?\u00b4\nUnwrap ::= Loc `!\u00b4\n\n\n\n\nSizeof\n\u00b6\n\n\nA \nsizeof\n expression returns the size of a type or expression, in bytes:\n\n\nSizeof ::= sizeof `(\u00b4 (Type|Exp) `)\u00b4\n\n\n\n\n\n\n\nCalls\n\u00b6\n\n\nSee \nNative Call\n and\n\nCode Invocation\n.\n\n\nVectors\n\u00b6\n\n\nIndex\n\u00b6\n\n\nC\u00e9u uses square brackets to index \nvectors\n:\n\n\nVec_Idx ::= Loc `[\u00b4 Exp `]\u00b4\n\n\n\n\nThe index expression must be of type \nusize\n.\n\n\nVectors start at index zero.\nC\u00e9u generates an \nerror\n for out-of-bounds vector accesses.\n\n\nLength\n\u00b6\n\n\nThe operator \n$\n returns the current length of a vector, while the operator\n\n$$\n returns the max length:\n\n\nVec_Len ::= `$\u00b4  Loc\nVec_Max ::= `$$\u00b4 Loc\n\n\n\n\nTODO: max\n\n\nThe vector length can also be assigned:\n\n\nvar[] int vec = [ 1, 2, 3 ];\n$vec = 1;\n\n\n\n\nThe new length must be smaller or equal to the current length, otherwise the\nassignment raises a runtime error.\nThe space for \ndynamic vectors\n shrinks automatically.\n\n\nConstructor\n\u00b6\n\n\nVector constructors are only valid in \nassignments\n:\n\n\nVec_Cons   ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n            |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\nVec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n\n\n\n\nExamples:\n\n\nvar[3] int v;        // declare an empty vector of length 3     (v = [])\nv = v .. [8];        // append value '8' to the empty vector    (v = [8])\nv = v .. [1] .. [5]; // append values '1' and '5' to the vector (v = [8, 1, 5])\n\n\n\n\nFields\n\u00b6\n\n\nThe operators \n.\n and \n:\n access public fields of\n\ndata abstractions\n,\n\ncode abstractions\n,\nand\n\nnative\n structs:\n\n\nDot   ::= Loc `.\u00b4 (ID_int|ID_nat)\nColon ::= Loc `:\u00b4 (ID_int|ID_nat)\n\n\n\n\nThe expression \ne:f\n is a sugar for \n(*e).f\n.\n\n\nTODO: ID_nat to avoid clashing with C\u00e9u keywords.",
            "title": "Locations & Expressions"
        },
        {
            "location": "/expressions/#locations-expressions",
            "text": "C\u00e9u specifies  locations  and expressions as\nfollows:  Exp ::= NUM | STR | null | true | false | on | off | yes | no\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp <binop> Exp\n     |  <unop> Exp\n     |  Exp (`:\u00b4|`.\u00b4) (ID_int|ID_nat)\n     |  Exp (`?\u00b4|`!\u00b4)\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp `(\u00b4 [ LIST(Exp) ] `)\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n     |  ID_int\n     |  ID_nat\n     |  outer\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 <code in C> `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    <=    >=    <     >\n    |\n    ^\n    &\n    <<    >>\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     &&    &   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */",
            "title": "Locations &amp; Expressions"
        },
        {
            "location": "/expressions/#primary",
            "text": "TODO",
            "title": "Primary"
        },
        {
            "location": "/expressions/#outer",
            "text": "TODO",
            "title": "Outer"
        },
        {
            "location": "/expressions/#arithmetic",
            "text": "C\u00e9u supports the arithmetic expressions  addition ,  subtraction , modulo (remainder) ,  multiplication ,  division ,  unary-plus , and unary-minus  through the operators that follow:      +      -      %      *      /      +      -",
            "title": "Arithmetic"
        },
        {
            "location": "/expressions/#bitwise",
            "text": "C\u00e9u supports the bitwise expressions  not ,  and ,  or ,  xor ,  left-shift ,\nand  right-shift  through the operators that follow:      ~      &      |      ^      <<      >>",
            "title": "Bitwise"
        },
        {
            "location": "/expressions/#relational",
            "text": "C\u00e9u supports the relational expressions  equal-to ,  not-equal-to , greater-than ,  less-than ,  greater-than-or-equal-to , and less-than-or-equal-to  through the operators that follow:      ==      !=      >      <      >=      <=  Relational expressions evaluate to  true  or  false .",
            "title": "Relational"
        },
        {
            "location": "/expressions/#logical",
            "text": "C\u00e9u supports the logical expressions  not ,  and , and  or  through the\noperators that follow:      not      and      or  Logical expressions evaluate to  true  or  false .",
            "title": "Logical"
        },
        {
            "location": "/expressions/#types",
            "text": "C\u00e9u supports type checks and casts:  Check ::= Exp is Type\nCast  ::= Exp as Type",
            "title": "Types"
        },
        {
            "location": "/expressions/#type-check",
            "text": "A type check evaluates to  true  or  false  depending on whether the runtime\ntype of the expression is a subtype of the checked type or not.  The static type of the expression must be a supertype of the checked type.  Example:  data Aa;\ndata Aa.Bb;\nvar Aa a = <...>;       // \"a\" is of static type \"Aa\"\n<...>\nif a is Aa.Bb then      // is the runtime type of \"a\" a subtype of \"Aa.Bb\"?\n    <...>\nend",
            "title": "Type Check"
        },
        {
            "location": "/expressions/#type-cast",
            "text": "A type cast converts the type of an expression into a new type as follows:   The expression type is a  data type :  The new type is  int :\n    Evaluates to the  type enumeration  for the\n    expression type.  The new type is a subtype of the expression static type:  The expression runtime type is a subtype of the new type:\n    Evaluates to the new type.  Evaluates to error.    The new type is a supertype of the expression static type:\n    Always succeeds and evaluates to the new type.\n    See also  Dynamic Dispatching .  Evaluates to error.    Evaluates to the new type (i.e., a  weak typecast , as in C).   Examples:  var Direction dir = <...>;\n_printf(\"dir = %d\\n\", dir as int);\n\nvar Aa a = <...>;\n_printf(\"a.v = %d\\n\", (a as Aa.Bb).v);\n\nvar Media.Video vid = <...>;\nawait/dynamic Play(&m as Media);\n\nvar bool b = <...>;\n_printf(\"b= %d\\n\", b as int);",
            "title": "Type Cast"
        },
        {
            "location": "/expressions/#modifiers",
            "text": "Expressions that evaluate to native types can be modified as follows:  Mod ::= Exp as `/\u00b4(nohold|plain|pure)  Modifiers may suppress the requirement for resource finalization .",
            "title": "Modifiers"
        },
        {
            "location": "/expressions/#references",
            "text": "C\u00e9u supports  aliases  and  pointers  as references .",
            "title": "References"
        },
        {
            "location": "/expressions/#aliases",
            "text": "An alias is acquired by prefixing a  native call \nor a  location  with the operator  & :  Alias ::= `&\u00b4 (Nat_Call | Loc)  See also the  unwrap operator   !  for option variable aliases.",
            "title": "Aliases"
        },
        {
            "location": "/expressions/#pointers",
            "text": "The operator  &&  returns the address of a location , while the operator  *  dereferences\na pointer:  Addr  ::= `&&\u00b4 Loc\nDeref ::= `*\u00b4 Loc",
            "title": "Pointers"
        },
        {
            "location": "/expressions/#option",
            "text": "The operator  ?  checks if the  location  of an option type  is set, while the operator  !  unwraps the\nlocation, raising an  error  if it is unset:  Check  ::= Loc `?\u00b4\nUnwrap ::= Loc `!\u00b4",
            "title": "Option"
        },
        {
            "location": "/expressions/#sizeof",
            "text": "A  sizeof  expression returns the size of a type or expression, in bytes:  Sizeof ::= sizeof `(\u00b4 (Type|Exp) `)\u00b4",
            "title": "Sizeof"
        },
        {
            "location": "/expressions/#calls",
            "text": "See  Native Call  and Code Invocation .",
            "title": "Calls"
        },
        {
            "location": "/expressions/#vectors",
            "text": "",
            "title": "Vectors"
        },
        {
            "location": "/expressions/#index",
            "text": "C\u00e9u uses square brackets to index  vectors :  Vec_Idx ::= Loc `[\u00b4 Exp `]\u00b4  The index expression must be of type  usize .  Vectors start at index zero.\nC\u00e9u generates an  error  for out-of-bounds vector accesses.",
            "title": "Index"
        },
        {
            "location": "/expressions/#length",
            "text": "The operator  $  returns the current length of a vector, while the operator $$  returns the max length:  Vec_Len ::= `$\u00b4  Loc\nVec_Max ::= `$$\u00b4 Loc  TODO: max  The vector length can also be assigned:  var[] int vec = [ 1, 2, 3 ];\n$vec = 1;  The new length must be smaller or equal to the current length, otherwise the\nassignment raises a runtime error.\nThe space for  dynamic vectors  shrinks automatically.",
            "title": "Length"
        },
        {
            "location": "/expressions/#constructor",
            "text": "Vector constructors are only valid in  assignments :  Vec_Cons   ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n            |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\nVec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)  Examples:  var[3] int v;        // declare an empty vector of length 3     (v = [])\nv = v .. [8];        // append value '8' to the empty vector    (v = [8])\nv = v .. [1] .. [5]; // append values '1' and '5' to the vector (v = [8, 1, 5])",
            "title": "Constructor"
        },
        {
            "location": "/expressions/#fields",
            "text": "The operators  .  and  :  access public fields of data abstractions , code abstractions ,\nand native  structs:  Dot   ::= Loc `.\u00b4 (ID_int|ID_nat)\nColon ::= Loc `:\u00b4 (ID_int|ID_nat)  The expression  e:f  is a sugar for  (*e).f .  TODO: ID_nat to avoid clashing with C\u00e9u keywords.",
            "title": "Fields"
        },
        {
            "location": "/compilation/",
            "text": "Compilation\n\u00b6\n\n\nThe compiler converts an input program in C\u00e9u to an output in C, which is\nfurther embedded in an \nenvironment\n satisfying a\n\nC API\n, which is finally compiled to an executable:\n\n\n\n\nCommand Line\n\u00b6\n\n\nThe single command \nceu\n is used for all compilation phases:\n\n\nUsage: ceu [<options>] <file>...\n\nOptions:\n\n    --help                          display this help, then exit\n    --version                       display version information, then exit\n\n    --pre                           Preprocessor phase: preprocess C\u00e9u into C\u00e9u\n    --pre-exe=FILE                      preprocessor executable\n    --pre-args=ARGS                     preprocessor arguments\n    --pre-input=FILE                    input file to compile (C\u00e9u source)\n    --pre-output=FILE                   output file to generate (C\u00e9u source)\n\n    --ceu                           C\u00e9u phase: compiles C\u00e9u into C\n    --ceu-input=FILE                    input file to compile (C\u00e9u source)\n    --ceu-output=FILE                   output source file to generate (C source)\n    --ceu-line-directives=BOOL          insert `#line` directives in the C output (default `true`)\n\n    --ceu-features-trace=BOOL           enable trace support (default `false`)\n    --ceu-features-exception=BOOL       enable exceptions support (default `false`)\n    --ceu-features-dynamic=BOOL         enable dynamic allocation support (default `false`)\n    --ceu-features-pool=BOOL            enable pool support (default `false`)\n    --ceu-features-lua=BOOL             enable `lua` support (default `false`)\n    --ceu-features-thread=BOOL          enable `async/thread` support (default `false`)\n    --ceu-features-isr=BOOL             enable `async/isr` support (default `false`)\n    --ceu-features-pause=BOOL           enable `pause/if` support (default `false`)\n\n    --ceu-err-unused=OPT                effect for unused identifier: error|warning|pass\n    --ceu-err-unused-native=OPT                    unused native identifier\n    --ceu-err-unused-code=OPT                      unused code identifier\n    --ceu-err-uninitialized=OPT         effect for uninitialized variable: error|warning|pass\n    --ceu-err-uncaught-exception=OPT    effect for uncaught exception: error|warning|pass\n    --ceu-err-uncaught-exception-main=OPT   ... at the main block (outside `code` abstractions)\n    --ceu-err-uncaught-exception-lua=OPT    ... from Lua code\n\n    --env                           Environment phase: packs all C files together\n    --env-types=FILE                    header file with type declarations (C source)\n    --env-threads=FILE                  header file with thread declarations (C source)\n    --env-ceu=FILE                      output file from C\u00e9u phase (C source)\n    --env-main=FILE                     source file with main function (C source)\n    --env-output=FILE                   output file to generate (C source)\n\n    --cc                            C phase: compiles C into binary\n    --cc-exe=FILE                       C compiler executable\n    --cc-args=ARGS                      compiler arguments\n    --cc-input=FILE                     input file to compile (C source)\n    --cc-output=FILE                    output file to generate (binary)\n\n\n\n\nAll phases are optional.\nTo enable a phase, the associated prefix must be enabled.\nIf two consecutive phases are enabled, the output of the preceding and the\ninput of the succeeding phases can be omitted.\n\n\nExamples:\n\n\n# Preprocess \"user.ceu\", and converts the output to \"user.c\"\n$ ceu --pre --pre-input=\"user.ceu\" --ceu --ceu-output=\"user.c\"\n\n\n\n\n# Packs \"user.c\", \"types.h\", and \"main.c\", compiling them to \"app.out\"\n$ ceu --env --env-ceu=user.c --env-types=types.h --env-main=main.c \\\n      --cc --cc-output=app.out\n\n\n\n\nC API\n\u00b6\n\n\nThe environment phase of the compiler packs the converted C\u00e9u program and\nadditional files in the order as follows:\n\n\n\n\ntype declarations    (option \n--env-types\n)\n\n\nthread declarations  (option \n--env-threads\n, optional)\n\n\na callback prototype (fixed, see below)\n\n\nC\u00e9u program          (option \n--env-ceu\n, auto generated)\n\n\nmain program         (option \n--env-main\n)\n\n\n\n\nThe C\u00e9u program uses standardized types and calls, which must be previously\nmapped from the host environment in steps \n1-3\n.\n\n\nThe main program depends on declarations from the C\u00e9u program.\n\n\nTypes\n\u00b6\n\n\nThe type declarations must map the types of the host environment to all\n\nprimitive types\n of C\u00e9u.\n\n\nExample:\n\n\n#include <stdint.h>\n#include <sys/types.h>\n\ntypedef unsigned char bool;\ntypedef unsigned char byte;\ntypedef unsigned int  uint;\n\ntypedef ssize_t  ssize;\ntypedef size_t   usize;\n\ntypedef int8_t    s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\ntypedef uint8_t   u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n\ntypedef float    real;\ntypedef float    r32;\ntypedef double   r64;\n\n\n\n\nThreads\n\u00b6\n\n\nIf the user program uses \nthreads\n and the option\n\n--ceu-features-thread\n is set, the host environment must provide declarations\nfor types and functions expected by C\u00e9u.\n\n\nExample:\n\n\n#include <pthread.h>\n#include <unistd.h>\n#define CEU_THREADS_T               pthread_t\n#define CEU_THREADS_MUTEX_T         pthread_mutex_t\n#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)\n#define CEU_THREADS_CANCEL(t)       ceu_dbg_assert(pthread_cancel(t)==0)\n#define CEU_THREADS_JOIN_TRY(t)     0\n#define CEU_THREADS_JOIN(t)         ceu_dbg_assert(pthread_join(t,NULL)==0)\n#define CEU_THREADS_MUTEX_LOCK(m)   ceu_dbg_assert(pthread_mutex_lock(m)==0)\n#define CEU_THREADS_MUTEX_UNLOCK(m) ceu_dbg_assert(pthread_mutex_unlock(m)==0)\n#define CEU_THREADS_SLEEP(us)       usleep(us)\n#define CEU_THREADS_PROTOTYPE(f,p)  void* f (p)\n#define CEU_THREADS_RETURN(v)       return v\n\n\n\n\nTODO: describe them\n\n\nC\u00e9u\n\u00b6\n\n\nThe converted program generates types and constants required by the main\nprogram.\n\n\nExternal Events\n\u00b6\n\n\nFor each \nexternal input and output event\n\n\n<ID>\n defined in C\u00e9u, the compiler generates corresponding declarations as\nfollows:\n\n\n\n\nAn enumeration item \nCEU_INPUT_<ID>\n that univocally identifies the event.\n\n\nA \ndefine\n macro \n_CEU_INPUT_<ID>_\n.\n\n\nA struct type \ntceu_input_<ID>\n with fields corresponding to the types in\n   of the event payload.\n\n\n\n\nExample:\n\n\nC\u00e9u program:\n\n\ninput (int,u8&&) MY_EVT;\n\n\n\n\nConverted program:\n\n\nenum {\n    ...\n    CEU_INPUT_MY_EVT,\n    ...\n};\n\n#define _CEU_INPUT_MY_EVT_                                                         \n\ntypedef struct tceu_input_MY_EVT {                                               \n    int _1;                                                                     \n    u8* _2;                                                                     \n} tceu_input_MY_EVT;\n\n\n\n\nData\n\u00b6\n\n\nThe global \nCEU_APP\n of type \ntceu_app\n holds all program memory and runtime\ninformation:\n\n\ntypedef struct tceu_app {\n    bool end_ok;                /* if the program terminated */\n    int  end_val;               /* final value of the program */\n    bool async_pending;         /* if there is a pending \"async\" to execute */\n    ...\n    tceu_code_mem_ROOT root;    /* all C\u00e9u program memory */\n} tceu_app;\n\nstatic tceu_app CEU_APP;\n\n\n\n\nThe struct \ntceu_code_mem_ROOT\n holds the whole memory of the C\u00e9u program.\nThe identifiers for global variables are preserved, making them directly\naccessible.\n\n\nExample:\n\n\nvar int x = 10;\n\n\n\n\ntypedef struct tceu_code_mem_ROOT {                                             \n    ...\n    int  x;                                                                         \n} tceu_code_mem_ROOT;    \n\n\n\n\nMain\n\u00b6\n\n\nThe main program provides the entry point for the host platform (i.e., the\n\nmain\n function), implementing the event loop that senses the world and\nnotifies the C\u00e9u program about changes.\n\n\nThe main program interfaces with the C\u00e9u program in both directions:\n\n\n\n\nThrough direct calls, in the direction \nmain -> C\u00e9u\n, typically when new input is available.\n\n\nThrough callbacks, in the direction \nC\u00e9u -> main\n, typically when new output is available.\n\n\n\n\nCalls\n\u00b6\n\n\nThe functions that follow are called by the main program to command the\nexecution of C\u00e9u programs:\n\n\n\n\n\n\nvoid ceu_start (tceu_callback* cb, int argc, char* argv[])\n\n\nInitializes and starts the program.\nShould be called once.\nExpects a callback to register for further notifications.\nAlso receives the program arguments in \nargc\n and \nargv\n.\n\n\n\n\n\n\nvoid ceu_stop  (void)\n\n\nFinalizes the program.\nShould be called once.\n\n\n\n\n\n\nvoid ceu_input (tceu_nevt id, void* params)\n\n\nNotifies the program about an input \nid\n with a payload \nparams\n.\nShould be called whenever the event loop senses a change.\nThe call to \nceu_input(CEU_INPUT__ASYNC, NULL)\n makes\n\nasynchronous blocks\n to execute a step.\n\n\n\n\n\n\nint ceu_loop (tceu_callback* cb, int argc, char* argv[])\n\n\nImplements a simple loop encapsulating \nceu_start\n, \nceu_input\n, and\n\nceu_stop\n.\nOn each loop iteration, make a \nCEU_CALLBACK_STEP\n callback and generates\na \nCEU_INPUT__ASYNC\n input.\nShould be called once.\nReturns the final value of the program.\n\n\n\n\n\n\nvoid ceu_callback_register (tceu_callback* cb)\n\n\nRegisters a new callback.\n\n\n\n\n\n\nCallbacks\n\u00b6\n\n\nThe C\u00e9u program makes callbacks to the main program in specific situations:\n\n\nenum {\n    CEU_CALLBACK_START,                 /* once in the beginning of `ceu_start`             */\n    CEU_CALLBACK_STOP,                  /* once in the end of `ceu_stop`                    */\n    CEU_CALLBACK_STEP,                  /* on every iteration of `ceu_loop`                 */\n    CEU_CALLBACK_ABORT,                 /* whenever an error occurs                         */\n    CEU_CALLBACK_LOG,                   /* on error and debugging messages                  */\n    CEU_CALLBACK_TERMINATING,           /* once after executing the last statement          */\n    CEU_CALLBACK_ASYNC_PENDING,         /* whenever there's a pending \"async\" block         */\n    CEU_CALLBACK_THREAD_TERMINATING,    /* whenever a thread terminates                     */\n    CEU_CALLBACK_ISR_ENABLE,            /* whenever interrupts should be enabled/disabled   */\n    CEU_CALLBACK_ISR_ATTACH,            /* whenever an \"async/isr\" starts                   */\n    CEU_CALLBACK_ISR_DETACH,            /* whenever an \"async/isr\" is aborted               */\n    CEU_CALLBACK_ISR_EMIT,              /* whenever an \"async/isr\" emits an innput          */\n    CEU_CALLBACK_WCLOCK_MIN,            /* whenever a next minimum timer is required        */\n    CEU_CALLBACK_WCLOCK_DT,             /* whenever the elapsed time is requested           */\n    CEU_CALLBACK_OUTPUT,                /* whenever an output is emitted                    */\n    CEU_CALLBACK_REALLOC,               /* whenever memory is allocated/deallocated         */\n};\n\n\n\n\nTODO: payloads\n\n\nC\u00e9u invokes the registered callbacks in reverse register order, one after the\nother, stopping when a callback returns that it handled the request.\n\n\nA callback is composed of a function handler and a pointer to the next\ncallback:\n\n\ntypedef struct tceu_callback {\n    tceu_callback_f       f;\n    struct tceu_callback* nxt;\n} tceu_callback;\n\n\n\n\nA handler expects a request identifier with two arguments, as well as runtime\ntrace information (e.g., file name and line number of the request):\n\n\ntypedef int (*tceu_callback_f) (int, tceu_callback_val, tceu_callback_val, tceu_trace);\n\n\n\n\nAn argument has one of the following types:\n\n\ntypedef union tceu_callback_val {\n    void* ptr;\n    s32   num;\n    usize size;\n} tceu_callback_val;\n\n\n\n\nA handler returns whether it handled the request or not (return type \nint\n).\n\n\nDepending on the request, the handler must also assign a return value to the\nglobal \nceu_callback_ret\n:\n\n\nstatic tceu_callback_val ceu_callback_ret;\n\n\n\n\n\n\n\nExample\n\u00b6\n\n\nSuppose the environment supports the events that follow:\n\n\ninput  int I;\noutput int O;\n\n\n\n\nThe \nmain.c\n implements an event loop to sense occurrences of \nI\n and a\ncallback to handle occurrences of \nO\n:\n\n\n#include \"types.h\"      // as illustrated above in \"Types\"\n\nint ceu_is_running;     // detects program termination\n\nint ceu_callback_main (int cmd, tceu_callback_val p1, tceu_callback_val p2, tceu_trace trace)\n{\n    int is_handled = 0;\n    switch (cmd) {\n        case CEU_CALLBACK_TERMINATING:\n            ceu_is_running = 0;\n            is_handled = 1;\n            break;\n        case CEU_CALLBACK_OUTPUT:\n            if (p1.num == CEU_OUTPUT_O) {\n                printf(\"output O has been emitted with %d\\n\", p2.num);\n                is_handled = 1;\n            }\n            break;\n    }\n    return ret;\n}\n\nint main (int argc, char* argv[])\n{\n    ceu_is_running = 1;\n    tceu_callback cb = { &ceu_callback_main, NULL };\n    ceu_start(&cb, argc, argv);\n\n    while (ceu_is_running) {\n        if (<call-to-detect-if-A-occurred>()) {\n            int v = <argument-to-A>;\n            ceu_input(CEU_INPUT_A, &v);\n        }\n        ceu_input(CEU_INPUT__ASYNC, NULL);\n    }\n\n    ceu_stop();\n}",
            "title": "Compilation"
        },
        {
            "location": "/compilation/#compilation",
            "text": "The compiler converts an input program in C\u00e9u to an output in C, which is\nfurther embedded in an  environment  satisfying a C API , which is finally compiled to an executable:",
            "title": "Compilation"
        },
        {
            "location": "/compilation/#command-line",
            "text": "The single command  ceu  is used for all compilation phases:  Usage: ceu [<options>] <file>...\n\nOptions:\n\n    --help                          display this help, then exit\n    --version                       display version information, then exit\n\n    --pre                           Preprocessor phase: preprocess C\u00e9u into C\u00e9u\n    --pre-exe=FILE                      preprocessor executable\n    --pre-args=ARGS                     preprocessor arguments\n    --pre-input=FILE                    input file to compile (C\u00e9u source)\n    --pre-output=FILE                   output file to generate (C\u00e9u source)\n\n    --ceu                           C\u00e9u phase: compiles C\u00e9u into C\n    --ceu-input=FILE                    input file to compile (C\u00e9u source)\n    --ceu-output=FILE                   output source file to generate (C source)\n    --ceu-line-directives=BOOL          insert `#line` directives in the C output (default `true`)\n\n    --ceu-features-trace=BOOL           enable trace support (default `false`)\n    --ceu-features-exception=BOOL       enable exceptions support (default `false`)\n    --ceu-features-dynamic=BOOL         enable dynamic allocation support (default `false`)\n    --ceu-features-pool=BOOL            enable pool support (default `false`)\n    --ceu-features-lua=BOOL             enable `lua` support (default `false`)\n    --ceu-features-thread=BOOL          enable `async/thread` support (default `false`)\n    --ceu-features-isr=BOOL             enable `async/isr` support (default `false`)\n    --ceu-features-pause=BOOL           enable `pause/if` support (default `false`)\n\n    --ceu-err-unused=OPT                effect for unused identifier: error|warning|pass\n    --ceu-err-unused-native=OPT                    unused native identifier\n    --ceu-err-unused-code=OPT                      unused code identifier\n    --ceu-err-uninitialized=OPT         effect for uninitialized variable: error|warning|pass\n    --ceu-err-uncaught-exception=OPT    effect for uncaught exception: error|warning|pass\n    --ceu-err-uncaught-exception-main=OPT   ... at the main block (outside `code` abstractions)\n    --ceu-err-uncaught-exception-lua=OPT    ... from Lua code\n\n    --env                           Environment phase: packs all C files together\n    --env-types=FILE                    header file with type declarations (C source)\n    --env-threads=FILE                  header file with thread declarations (C source)\n    --env-ceu=FILE                      output file from C\u00e9u phase (C source)\n    --env-main=FILE                     source file with main function (C source)\n    --env-output=FILE                   output file to generate (C source)\n\n    --cc                            C phase: compiles C into binary\n    --cc-exe=FILE                       C compiler executable\n    --cc-args=ARGS                      compiler arguments\n    --cc-input=FILE                     input file to compile (C source)\n    --cc-output=FILE                    output file to generate (binary)  All phases are optional.\nTo enable a phase, the associated prefix must be enabled.\nIf two consecutive phases are enabled, the output of the preceding and the\ninput of the succeeding phases can be omitted.  Examples:  # Preprocess \"user.ceu\", and converts the output to \"user.c\"\n$ ceu --pre --pre-input=\"user.ceu\" --ceu --ceu-output=\"user.c\"  # Packs \"user.c\", \"types.h\", and \"main.c\", compiling them to \"app.out\"\n$ ceu --env --env-ceu=user.c --env-types=types.h --env-main=main.c \\\n      --cc --cc-output=app.out",
            "title": "Command Line"
        },
        {
            "location": "/compilation/#c-api",
            "text": "The environment phase of the compiler packs the converted C\u00e9u program and\nadditional files in the order as follows:   type declarations    (option  --env-types )  thread declarations  (option  --env-threads , optional)  a callback prototype (fixed, see below)  C\u00e9u program          (option  --env-ceu , auto generated)  main program         (option  --env-main )   The C\u00e9u program uses standardized types and calls, which must be previously\nmapped from the host environment in steps  1-3 .  The main program depends on declarations from the C\u00e9u program.",
            "title": "C API"
        },
        {
            "location": "/compilation/#types",
            "text": "The type declarations must map the types of the host environment to all primitive types  of C\u00e9u.  Example:  #include <stdint.h>\n#include <sys/types.h>\n\ntypedef unsigned char bool;\ntypedef unsigned char byte;\ntypedef unsigned int  uint;\n\ntypedef ssize_t  ssize;\ntypedef size_t   usize;\n\ntypedef int8_t    s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\ntypedef uint8_t   u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n\ntypedef float    real;\ntypedef float    r32;\ntypedef double   r64;",
            "title": "Types"
        },
        {
            "location": "/compilation/#threads",
            "text": "If the user program uses  threads  and the option --ceu-features-thread  is set, the host environment must provide declarations\nfor types and functions expected by C\u00e9u.  Example:  #include <pthread.h>\n#include <unistd.h>\n#define CEU_THREADS_T               pthread_t\n#define CEU_THREADS_MUTEX_T         pthread_mutex_t\n#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)\n#define CEU_THREADS_CANCEL(t)       ceu_dbg_assert(pthread_cancel(t)==0)\n#define CEU_THREADS_JOIN_TRY(t)     0\n#define CEU_THREADS_JOIN(t)         ceu_dbg_assert(pthread_join(t,NULL)==0)\n#define CEU_THREADS_MUTEX_LOCK(m)   ceu_dbg_assert(pthread_mutex_lock(m)==0)\n#define CEU_THREADS_MUTEX_UNLOCK(m) ceu_dbg_assert(pthread_mutex_unlock(m)==0)\n#define CEU_THREADS_SLEEP(us)       usleep(us)\n#define CEU_THREADS_PROTOTYPE(f,p)  void* f (p)\n#define CEU_THREADS_RETURN(v)       return v  TODO: describe them",
            "title": "Threads"
        },
        {
            "location": "/compilation/#ceu",
            "text": "The converted program generates types and constants required by the main\nprogram.",
            "title": "C\u00e9u"
        },
        {
            "location": "/compilation/#external-events",
            "text": "For each  external input and output event  <ID>  defined in C\u00e9u, the compiler generates corresponding declarations as\nfollows:   An enumeration item  CEU_INPUT_<ID>  that univocally identifies the event.  A  define  macro  _CEU_INPUT_<ID>_ .  A struct type  tceu_input_<ID>  with fields corresponding to the types in\n   of the event payload.   Example:  C\u00e9u program:  input (int,u8&&) MY_EVT;  Converted program:  enum {\n    ...\n    CEU_INPUT_MY_EVT,\n    ...\n};\n\n#define _CEU_INPUT_MY_EVT_                                                         \n\ntypedef struct tceu_input_MY_EVT {                                               \n    int _1;                                                                     \n    u8* _2;                                                                     \n} tceu_input_MY_EVT;",
            "title": "External Events"
        },
        {
            "location": "/compilation/#data",
            "text": "The global  CEU_APP  of type  tceu_app  holds all program memory and runtime\ninformation:  typedef struct tceu_app {\n    bool end_ok;                /* if the program terminated */\n    int  end_val;               /* final value of the program */\n    bool async_pending;         /* if there is a pending \"async\" to execute */\n    ...\n    tceu_code_mem_ROOT root;    /* all C\u00e9u program memory */\n} tceu_app;\n\nstatic tceu_app CEU_APP;  The struct  tceu_code_mem_ROOT  holds the whole memory of the C\u00e9u program.\nThe identifiers for global variables are preserved, making them directly\naccessible.  Example:  var int x = 10;  typedef struct tceu_code_mem_ROOT {                                             \n    ...\n    int  x;                                                                         \n} tceu_code_mem_ROOT;",
            "title": "Data"
        },
        {
            "location": "/compilation/#main",
            "text": "The main program provides the entry point for the host platform (i.e., the main  function), implementing the event loop that senses the world and\nnotifies the C\u00e9u program about changes.  The main program interfaces with the C\u00e9u program in both directions:   Through direct calls, in the direction  main -> C\u00e9u , typically when new input is available.  Through callbacks, in the direction  C\u00e9u -> main , typically when new output is available.",
            "title": "Main"
        },
        {
            "location": "/compilation/#calls",
            "text": "The functions that follow are called by the main program to command the\nexecution of C\u00e9u programs:    void ceu_start (tceu_callback* cb, int argc, char* argv[])  Initializes and starts the program.\nShould be called once.\nExpects a callback to register for further notifications.\nAlso receives the program arguments in  argc  and  argv .    void ceu_stop  (void)  Finalizes the program.\nShould be called once.    void ceu_input (tceu_nevt id, void* params)  Notifies the program about an input  id  with a payload  params .\nShould be called whenever the event loop senses a change.\nThe call to  ceu_input(CEU_INPUT__ASYNC, NULL)  makes asynchronous blocks  to execute a step.    int ceu_loop (tceu_callback* cb, int argc, char* argv[])  Implements a simple loop encapsulating  ceu_start ,  ceu_input , and ceu_stop .\nOn each loop iteration, make a  CEU_CALLBACK_STEP  callback and generates\na  CEU_INPUT__ASYNC  input.\nShould be called once.\nReturns the final value of the program.    void ceu_callback_register (tceu_callback* cb)  Registers a new callback.",
            "title": "Calls"
        },
        {
            "location": "/compilation/#callbacks",
            "text": "The C\u00e9u program makes callbacks to the main program in specific situations:  enum {\n    CEU_CALLBACK_START,                 /* once in the beginning of `ceu_start`             */\n    CEU_CALLBACK_STOP,                  /* once in the end of `ceu_stop`                    */\n    CEU_CALLBACK_STEP,                  /* on every iteration of `ceu_loop`                 */\n    CEU_CALLBACK_ABORT,                 /* whenever an error occurs                         */\n    CEU_CALLBACK_LOG,                   /* on error and debugging messages                  */\n    CEU_CALLBACK_TERMINATING,           /* once after executing the last statement          */\n    CEU_CALLBACK_ASYNC_PENDING,         /* whenever there's a pending \"async\" block         */\n    CEU_CALLBACK_THREAD_TERMINATING,    /* whenever a thread terminates                     */\n    CEU_CALLBACK_ISR_ENABLE,            /* whenever interrupts should be enabled/disabled   */\n    CEU_CALLBACK_ISR_ATTACH,            /* whenever an \"async/isr\" starts                   */\n    CEU_CALLBACK_ISR_DETACH,            /* whenever an \"async/isr\" is aborted               */\n    CEU_CALLBACK_ISR_EMIT,              /* whenever an \"async/isr\" emits an innput          */\n    CEU_CALLBACK_WCLOCK_MIN,            /* whenever a next minimum timer is required        */\n    CEU_CALLBACK_WCLOCK_DT,             /* whenever the elapsed time is requested           */\n    CEU_CALLBACK_OUTPUT,                /* whenever an output is emitted                    */\n    CEU_CALLBACK_REALLOC,               /* whenever memory is allocated/deallocated         */\n};  TODO: payloads  C\u00e9u invokes the registered callbacks in reverse register order, one after the\nother, stopping when a callback returns that it handled the request.  A callback is composed of a function handler and a pointer to the next\ncallback:  typedef struct tceu_callback {\n    tceu_callback_f       f;\n    struct tceu_callback* nxt;\n} tceu_callback;  A handler expects a request identifier with two arguments, as well as runtime\ntrace information (e.g., file name and line number of the request):  typedef int (*tceu_callback_f) (int, tceu_callback_val, tceu_callback_val, tceu_trace);  An argument has one of the following types:  typedef union tceu_callback_val {\n    void* ptr;\n    s32   num;\n    usize size;\n} tceu_callback_val;  A handler returns whether it handled the request or not (return type  int ).  Depending on the request, the handler must also assign a return value to the\nglobal  ceu_callback_ret :  static tceu_callback_val ceu_callback_ret;",
            "title": "Callbacks"
        },
        {
            "location": "/compilation/#example",
            "text": "Suppose the environment supports the events that follow:  input  int I;\noutput int O;  The  main.c  implements an event loop to sense occurrences of  I  and a\ncallback to handle occurrences of  O :  #include \"types.h\"      // as illustrated above in \"Types\"\n\nint ceu_is_running;     // detects program termination\n\nint ceu_callback_main (int cmd, tceu_callback_val p1, tceu_callback_val p2, tceu_trace trace)\n{\n    int is_handled = 0;\n    switch (cmd) {\n        case CEU_CALLBACK_TERMINATING:\n            ceu_is_running = 0;\n            is_handled = 1;\n            break;\n        case CEU_CALLBACK_OUTPUT:\n            if (p1.num == CEU_OUTPUT_O) {\n                printf(\"output O has been emitted with %d\\n\", p2.num);\n                is_handled = 1;\n            }\n            break;\n    }\n    return ret;\n}\n\nint main (int argc, char* argv[])\n{\n    ceu_is_running = 1;\n    tceu_callback cb = { &ceu_callback_main, NULL };\n    ceu_start(&cb, argc, argv);\n\n    while (ceu_is_running) {\n        if (<call-to-detect-if-A-occurred>()) {\n            int v = <argument-to-A>;\n            ceu_input(CEU_INPUT_A, &v);\n        }\n        ceu_input(CEU_INPUT__ASYNC, NULL);\n    }\n\n    ceu_stop();\n}",
            "title": "Example"
        },
        {
            "location": "/syntax/",
            "text": "Syntax\n\u00b6\n\n\nFollows the complete syntax of C\u00e9u in a BNF-like syntax:\n\n\n\n\nA\n : non terminal (starting in uppercase)\n\n\na\n : terminal (in bold and lowercase)\n\n\n`.\u00b4\n : terminal (non-alphanumeric characters)\n\n\nA ::= ...\n : defines \nA\n as \n...\n\n\nx y\n : \nx\n in sequence with \ny\n\n\nx|y\n : \nx\n or \ny\n\n\n{x}\n : zero or more xs\n\n\n[x]\n : optional x\n\n\nLIST(x)\n : expands to \nx {`,\u00b4 x} [`,\u00b4]\n\n\n(...)\n : groups \n...\n\n\n<...>\n : special informal rule\n\n\n\n\n\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n            Block\n        end\n      | escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Entities / Declarations */\n\n      // Dcls ::=\n      | var [`&\u00b4|`&?\u00b4] `[\u00b4 [Exp [`*\u00b4]] `]\u00b4 [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\n      | pool [`&\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | event [`&\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      | output (Type | `(\u00b4 LIST([`&\u00b4] Type [ID_int]) `)\u00b4) ID_ext\n            [ do Block end ]\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp|`_\u00b4)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp|`_\u00b4)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `->\u00b4 (Exp|`_\u00b4))\n                        | ((Exp|`_\u00b4) `<-\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Abs_Cons) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n            Block\n        end\n\n  /* Exceptions */\n\n      | throw Exp\n      | catch LIST(Loc) do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      | spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 LIST(ID_nat) `)\u00b4\n      | native `/\u00b4(pre|pos) do\n            <code definitions in C>\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 {<code in C> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\n      // Nat_Call ::=\n      | [call] Exp\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var [`&\u00b4|`&?\u00b4] Type ID_int `=\u00b4 `&\u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize [ `(\u00b4 LIST(Loc) `)\u00b4 ] with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { {<code in Lua> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            Dcls `;\u00b4 { Dcls `;\u00b4 }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `->\u00b4 Type\n\n      // Code_Await ::=\n      | code/await Mods ID_abs `(\u00b4 Params `)\u00b4\n                                    [ `->\u00b4 `(\u00b4 Params `)\u00b4 ]\n                                        `->\u00b4 (Type | NEVER)\n                                [ throws LIST(ID_abs) ]\n        // where\n            Params ::= none | LIST(Dcls)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Abs_Cons [in Loc]\n      | kill Loc [ `(` Exp `)` ]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n        // where\n            Sources ::= ( Do\n                        | Emit_Ext\n                        | Await\n                        | Watching\n                        | Thread\n                        | Lua_Stmts\n                        | Code_Await\n                        | Code_Spawn\n                        | Vec_Cons\n                        | Data_Cons\n                        | Exp\n                        | `_\u00b4 )\n            Vec_Cons  ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n                       |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\n                        // where\n                            Vec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | none\n             | bool  | on/off | yes/no\n             | byte\n             | r32   | r64    | real\n             | s8    | s16    | s32     | s64\n             | u8    | u16    | u32     | u64\n             | int   | uint   | integer\n             | ssize   | usize )\n\n/* Types */\n\nType ::= ID_type { `&&\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \" [^\\\"\\n]* \"                        // regex\n\n/* Expressions */\n\nExp ::= NUM | STR | null | true | false | on | off | yes | no\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp <binop> Exp\n     |  <unop> Exp\n     |  Exp (`:\u00b4|`.\u00b4) (ID_int|ID_nat)\n     |  Exp (`?\u00b4|`!\u00b4)\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp `(\u00b4 [ LIST(Exp) ] `)\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n     |  ID_int\n     |  ID_nat\n     |  outer\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 <code in C> `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    <=    >=    <     >\n    |\n    ^\n    &\n    <<    >>\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     &&    &   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive\n\n\n\n\n\nTODO: statements that do not require ;",
            "title": "Syntax"
        },
        {
            "location": "/syntax/#syntax",
            "text": "Follows the complete syntax of C\u00e9u in a BNF-like syntax:   A  : non terminal (starting in uppercase)  a  : terminal (in bold and lowercase)  `.\u00b4  : terminal (non-alphanumeric characters)  A ::= ...  : defines  A  as  ...  x y  :  x  in sequence with  y  x|y  :  x  or  y  {x}  : zero or more xs  [x]  : optional x  LIST(x)  : expands to  x {`,\u00b4 x} [`,\u00b4]  (...)  : groups  ...  <...>  : special informal rule    Program ::= Block\nBlock   ::= {Stmt `;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n            Block\n        end\n      | escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Entities / Declarations */\n\n      // Dcls ::=\n      | var [`&\u00b4|`&?\u00b4] `[\u00b4 [Exp [`*\u00b4]] `]\u00b4 [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\n      | pool [`&\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | event [`&\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      | output (Type | `(\u00b4 LIST([`&\u00b4] Type [ID_int]) `)\u00b4) ID_ext\n            [ do Block end ]\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp|`_\u00b4)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp|`_\u00b4)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `->\u00b4 (Exp|`_\u00b4))\n                        | ((Exp|`_\u00b4) `<-\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Abs_Cons) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n            Block\n        end\n\n  /* Exceptions */\n\n      | throw Exp\n      | catch LIST(Loc) do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      | spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 LIST(ID_nat) `)\u00b4\n      | native `/\u00b4(pre|pos) do\n            <code definitions in C>\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 {<code in C> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\n      // Nat_Call ::=\n      | [call] Exp\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var [`&\u00b4|`&?\u00b4] Type ID_int `=\u00b4 `&\u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize [ `(\u00b4 LIST(Loc) `)\u00b4 ] with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { {<code in Lua> | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            Dcls `;\u00b4 { Dcls `;\u00b4 }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `->\u00b4 Type\n\n      // Code_Await ::=\n      | code/await Mods ID_abs `(\u00b4 Params `)\u00b4\n                                    [ `->\u00b4 `(\u00b4 Params `)\u00b4 ]\n                                        `->\u00b4 (Type | NEVER)\n                                [ throws LIST(ID_abs) ]\n        // where\n            Params ::= none | LIST(Dcls)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Abs_Cons [in Loc]\n      | kill Loc [ `(` Exp `)` ]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n        // where\n            Sources ::= ( Do\n                        | Emit_Ext\n                        | Await\n                        | Watching\n                        | Thread\n                        | Lua_Stmts\n                        | Code_Await\n                        | Code_Spawn\n                        | Vec_Cons\n                        | Data_Cons\n                        | Exp\n                        | `_\u00b4 )\n            Vec_Cons  ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n                       |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\n                        // where\n                            Vec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | none\n             | bool  | on/off | yes/no\n             | byte\n             | r32   | r64    | real\n             | s8    | s16    | s32     | s64\n             | u8    | u16    | u32     | u64\n             | int   | uint   | integer\n             | ssize   | usize )\n\n/* Types */\n\nType ::= ID_type { `&&\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \" [^\\\"\\n]* \"                        // regex\n\n/* Expressions */\n\nExp ::= NUM | STR | null | true | false | on | off | yes | no\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp <binop> Exp\n     |  <unop> Exp\n     |  Exp (`:\u00b4|`.\u00b4) (ID_int|ID_nat)\n     |  Exp (`?\u00b4|`!\u00b4)\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp `(\u00b4 [ LIST(Exp) ] `)\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n     |  ID_int\n     |  ID_nat\n     |  outer\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 <code in C> `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    <=    >=    <     >\n    |\n    ^\n    &\n    <<    >>\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     &&    &   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive  TODO: statements that do not require ;",
            "title": "Syntax"
        },
        {
            "location": "/license/",
            "text": "License\n\u00b6\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/license/#license",
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.",
            "title": "License"
        }
    ]
}